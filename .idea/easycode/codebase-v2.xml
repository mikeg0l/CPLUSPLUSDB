<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="com.obiscr.chatgpt.settings.EasyCodeState">
    <option name="projectFiles" value="$PROJECT_DIR$/database/database.cpp;C:/Users/golasmi1/workspace/CPLUSPLUSDB/database/database.h;C:/Users/golasmi1/workspace/CPLUSPLUSDB/table/datatype.h;C:/Users/golasmi1/workspace/CPLUSPLUSDB/table/table.cpp;C:/Users/golasmi1/workspace/CPLUSPLUSDB/table/table.h;C:/Users/golasmi1/workspace/CPLUSPLUSDB/table/tablerow.h;C:/Users/golasmi1/workspace/CPLUSPLUSDB/utils/mapper.cpp;C:/Users/golasmi1/workspace/CPLUSPLUSDB/utils/mapper.h;C:/Users/golasmi1/workspace/CPLUSPLUSDB/utils/parser.cpp;C:/Users/golasmi1/workspace/CPLUSPLUSDB/utils/parser.h;C:/Users/golasmi1/workspace/CPLUSPLUSDB/utils/printer.cpp;C:/Users/golasmi1/workspace/CPLUSPLUSDB/utils/printer.h;C:/Users/golasmi1/workspace/CPLUSPLUSDB/main.cpp" />
    <option name="forceFullIndex" value="false" />
    <option name="fileSummaryMaps" value="{&quot;C:/Users/sumer/CLionProjects/2324Z_19_s26525_FK&quot;:&quot;{\&quot;/cmake-build-debug/CMakeFiles/3.27.8/CompilerIdCXX/CMakeCXXCompilerId.cpp\&quot;:\&quot;This file is used to detect information about the compiler and build environment. It defines a number of macros that can be used to identify:\\n\\n- The compiler ID (e.g. GNU, MSVC, Intel, etc.)\\n- The compiler version numbers\\n- The platform (OS)\\n- The CPU/architecture\\n- The C++ language standard and default extensions\\n\\nSome key functions:\\n\\n- COMPILER_ID - Defines a string for the compiler identification \\n- COMPILER_VERSION_MAJOR/MINOR/PATCH - Extract major/minor/patch version numbers\\n- PLATFORM_ID - Defines a string for the platform/OS identification\\n- ARCHITECTURE_ID - Defines a string for the CPU/architecture  \\n- CXX_STD - Defines the default C++ language standard\\n- info_compiler, info_platform, etc. - Define string literals with compiler/platform info\\n- main() - Prints out all the defined information strings\\n\\nSo in summary, it detects detailed information about the build environment and exposes it via preprocessor macros and string literals for use by other code that may need to conditionally compile or report specifics about the compiler/platform.\&quot;,\&quot;/cmake-build-debug/.cmake/api/v1/reply/directory-.-Debug-d0094a50bb2071803777.json\&quot;:\&quot;This JSON file contains metadata about a CMake build directory.\\n\\nKey things it provides:\\n\\n- paths - Contains the paths to the build and source directories. This allows tools to locate where the build is taking place and the original source code.\\n\\n- backtraceGraph - Empty objects for commands, files, and nodes. This provides a place to store debugging information about the CMake execution backtrace/graph, but is empty here since debugging is not enabled. \\n\\n- installers - Empty array. This would contain information about custom install rules and targets if any were defined in the CMake code.\\n\\nSo in summary, its main functions are:\\n\\n- Provide location of build and source directories \\n- Reserve space for capturing CMake execution backtrace/graph (if debugging enabled)\\n- Reserve space for describing custom install rules (if defined)\\n\\nIt acts as a central metadata file in the build directory that tools can read to understand the context and configuration of the CMake build being performed.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/doc/conf.py\&quot;:\&quot;This file is the main configuration file for building the documentation for the fmt library using Sphinx.\\n\\nKey functions:\\n\\n- Configures Sphinx extensions like breathe for linking to Doxygen documentation.\\n\\n- Sets project metadata like name, copyright, author. \\n\\n- Configures Sphinx build options - formats, languages, templates, etc.\\n\\n- Configures HTML output - theme, static paths, sidebar templates, etc. \\n\\n- Configures other output formats like LaTeX, manual pages, Texinfo. \\n\\n- Defines mappings from source files to output files for different formats.\\n\\n- Runs Doxygen to generate XML files from code comments if building on ReadTheDocs.\\n\\nIn summary, it contains all the configuration needed by Sphinx to understand the project, parse the source files, and build the documentation in different output formats like HTML, PDF, etc. It links the code documentation generated by Doxygen so it can be included in Sphinx.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/.github/pull_request_template.md\&quot;:\&quot;This file is a pull request template for the fmt (formatting library) project on GitHub. \\n\\nSome key things it does:\\n\\n- Provides a comment block at the top to remind contributors to read the project\\u0027s contribution guidelines before submitting a PR. This helps ensure PRs follow the project\\u0027s standards and processes.\\n\\n- Asks contributors to agree to license their code under the project\\u0027s license terms by submitting the PR. This helps maintain a consistent license for all code in the project. \\n\\n- Provides a template for contributors to fill out with details about their proposed changes when opening a PR. Common things it asks for include a description of the changes, which issues it addresses, etc. \\n\\n- Helps structure and standardize the information provided in new PRs. This makes it easier for maintainers to review changes being proposed.\\n\\nSo in summary, the main functions of this file are:\\n\\n- Provide guidelines for contributors \\n- Ensure code is properly licensed\\n- Template out the information required in new PRs \\n- Help standardize the PR submission process\\n\\nIt\\u0027s a common pattern for open source projects to include a pull request template like this to streamline code contributions.\&quot;,\&quot;/cmake-build-debug/.cmake/api/v1/reply/cmakeFiles-v1-a387161b883541392b30.json\&quot;:\&quot;This file contains information about the CMake files used to build a CMake project.\\n\\nSome key things:\\n\\n- inputs: Lists all the CMake files that were used as inputs to the build. This includes the main CMakeLists.txt file, generated CMake files, and external CMake modules from the CMake installation.\\n\\n- kind: Indicates this is a \\\&quot;cmakeFiles\\\&quot; response, containing info about CMake files. \\n\\n- paths: Gives the build directory and source directory paths.\\n\\n- version: Version number of the CMakeFiles API.\\n\\nKey functions of the CMake files include:\\n\\n- Configuring the project - Setting up build options, compiler/linker flags, include paths etc.\\n- Generating build system files - Creating Makefiles, project files for IDEs etc. \\n- Finding and handling external dependencies\\n- Configuring tests and installing targets\\n- Cross-compiling and toolchain support\\n- Packaging and exporting targets\\n\\nSo in summary, this file provides a listing of all CMake input files used for the build, along with metadata about the project directories and CMakeFiles API version. The CMake files themselves define how the project is built.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/printf.h\&quot;:\&quot;This file defines functionality for formatted printing (printf-style formatting) in the fmt library.\\n\\nKey things it does:\\n\\n- Defines basic_printf_context and related types for handling printf arguments and formatting context.\\n\\n- Implements parsing of printf format strings and extraction of arguments, flags, widths, etc. \\n\\n- Defines printf_arg_formatter to format arguments according to printf specs.\\n\\n- Implements vprintf to format and print with a printf format string and arguments.\\n\\nKey functions:\\n\\n- make_printf_args - Constructs an argument store for printf arguments\\n- sprintf - Formats and returns a string \\n- fprintf - Prints formatted data to a file\\n- printf - Prints formatted data to stdout\\n- vprintf - Core formatting function that takes format string and arguments\\n- parse_header - Parses format string for argument index, flags, width\\n- printf_arg_formatter - Formats arguments according to printf specs\\n- convert_arg - Converts arguments to required type for printf\\n\\nSo in summary, it provides printf-style formatting for fmt by implementing the parsing, argument handling and formatting logic required for printf formats.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/std.h\&quot;:\&quot;This file (fmt/std.h) provides formatting support for standard library types in the fmt library.\\n\\nSome key things it does:\\n\\n- Defines formatters (templates specializing fmt::formatter) for common standard library types like std::string, std::vector, std::exception, etc. to allow formatting them with fmt.\\n\\n- Checks for availability of newer C++ standard library features like std::optional, std::variant, std::filesystem and conditionally includes their headers and defines formatters if available.\\n\\n- Defines utility functions and type traits used by the formatters, like checking if a type is formattable, writing escaped strings, handling dynamic width, etc. \\n\\n- Provides formatters for atomic types by delegating to the underlying non-atomic formatters.\\n\\n- Handles formatting of std::error_code by writing the category name and error value.\\n\\n- Special cases formatting std::exception to optionally print the type name if requested.\\n\\n- For std::bitset it formats each bit as 0/1 by iterating the bits.\\n\\nSo in summary, it enables seamless formatting of common standard types with fmt by defining the necessary formatter templates and utilities. This allows things like std containers, exceptions etc. to be formatted for output similar to user-defined types.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/support/rtd/theme/layout.html\&quot;:\&quot;This HTML file is used to redirect visitors from the Read the Docs documentation theme to the main fmt documentation site at fmt.dev/latest/.\\n\\nKey functions:\\n\\n- Extends the basic/layout.html template which provides the base layout and styling for RTD themes.\\n\\n- Adds a meta refresh tag that automatically refreshes the page to redirect to fmt.dev after 1 second. \\n\\n- Includes a JavaScript redirect that immediately redirects the page location to fmt.dev on page load.\\n\\n- Sets the page title to \\\&quot;Page Redirection\\\&quot;.\\n\\n- The document block displays a fallback message with a link to fmt.dev in case the automatic redirects don\\u0027t work.\\n\\n- It overrides the footer block to be empty, removing the default RTD footer.\\n\\nSo in summary, its purpose is to redirect visitors from the default RTD theme documentation to the main fmt site, using both meta refresh and JavaScript redirects to accomplish this seamlessly on page load.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/test/gtest/gtest/gtest.h\&quot;:\&quot;This file contains internal definitions and utilities used by Google Test, the C++ testing framework. Some key things it does:\\n\\n- Defines types and classes used internally by Google Test, like Message, TestInfo, TestPartResult, etc. These are not meant to be used directly by user code.\\n\\n- Defines macros and utilities used for writing tests like TEST, TEST_F, ASSERT_*, EXPECT_*, etc. \\n\\n- Defines type utilities like TypeId, GetTypeName() for getting type IDs and names. These are used for type-parameterized tests.\\n\\n- Defines floating point comparison utilities like FloatingPoint to do more robust floating point comparisons than just using \\u003d\\u003d.\\n\\n- Defines utilities for test fixtures and setting up/tearing down test suites and cases.\\n\\n- Defines utilities for registering and running tests - functions like MakeAndRegisterTestInfo(), RegisterTest(), RunAllTests(), etc.\\n\\n- Defines string and formatting utilities used across Google Test.\\n\\n- Defines macros for controlling test behavior like death tests, value-parameterized tests, etc.\\n\\nSome key functions include:\\n\\n- MakeAndRegisterTestInfo() - Creates and registers a TestInfo object.\\n- GetTypeId() - Gets a unique ID for a type. \\n- ASSERT_*, EXPECT_* - Assertion macros.\\n- TEST(), TEST_F() - Defines a test. \\n- RunAllTests() - Runs all registered tests.\\n- FloatingPoint::AlmostEquals() - Compares floats accounting for precision.\\n\\nSo in summary, it provides the core internal implementation and utilities required to write, register and run tests with Google Test.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/README.md\&quot;:\&quot;This README.md file is providing documentation and information about the fmt formatting library. Some key things it covers:\\n\\n- Overview and description of what fmt is and its main features\\n- Examples of how to use fmt for common formatting tasks\\n- Benchmark results comparing fmt\\u0027s performance to other libraries\\n- Instructions on building and running tests for fmt\\n- List of notable projects that use fmt\\n- Motivation for why fmt was created\\n- Information on licensing and maintaining the project\\n\\nSome key sections/functions:\\n\\n- Features - Lists the main capabilities of fmt\\n- Examples - Shows code samples of common usage patterns \\n- Benchmarks - Performance comparison data against other libraries\\n- Building/testing - Instructions for compiling and running tests\\n- Projects using fmt - List of major open source software using the library\\n- Motivation - Rationale for creating a new formatting library\\n- License/documentation license - Details on licensing terms\\n- Maintainers - Names of people maintaining the fmt project\\n\\nSo in summary, this README provides an overview of what fmt is, how to use it, why it was created, how it compares to other options, and details on contributing to and maintaining the project. It serves as the main documentation entry point for the fmt formatting library.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-subbuild/CMakeFiles/fmt-populate.dir/Labels.json\&quot;:\&quot;This file is a JSON file that contains labels and metadata for the CMake build process of the fmt (formatting library) subproject.\\n\\nKey things it does:\\n\\n- Lists the source files involved in building the fmt subproject, including CMake files, rules files, stamp files etc. These define the build steps.\\n\\n- Identifies the \\\&quot;target\\\&quot; of the build process, which is \\\&quot;fmt-populate\\\&quot;. \\n\\n- Associates the label \\\&quot;fmt-populate\\\&quot; with the target, to identify it.\\n\\n- Provides the name of the target as \\\&quot;fmt-populate\\\&quot;.\\n\\nSo in summary, it:\\n\\n- Defines the sources/files involved in the build \\n- Labels the target of the build process\\n- Identifies the name of the build target\\n\\nThis allows CMake and tools reading this file to understand the build dependencies and workflow for this component of the overall project build. It is part of the metadata used to drive the automated build process.\&quot;,\&quot;/cmake-build-debug/.cmake/api/v1/reply/codemodel-v2-dc0b8d9fd0ebbef7b2e8.json\&quot;:\&quot;This file contains the CMake code model for a CMake project build configuration.\\n\\nSome key things it provides:\\n\\n- Configurations - The top-level configurations, like Debug. Contains directories, projects, targets.\\n\\n- Directories - The source and build directories for the project and subprojects. Contains metadata like CMake version. \\n\\n- Projects - The top-level projects, like the main project and subprojects like FMT. \\n\\n- Targets - The build targets, like executables and libraries. Contains metadata like target name and project. \\n\\n- Relationships - Shows how directories, projects and targets are related via indexes.\\n\\nThe main functions of this file are:\\n\\n- Describe the directory, project and target structure of the build configuration\\n- Provide metadata for each component like CMake version requirements\\n- Link related components together via indexes \\n- Provide file paths to locate additional JSON files with more details\\n\\nThis allows tools like IDEs to understand the build configuration and project structure, locate relevant files, and integrate CMake features like building, installing and debugging targets.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/compile.h\&quot;:\&quot;This file defines functionality for compile-time format string compilation in the fmt formatting library.\\n\\nSome key things it does:\\n\\n- Defines the FMT_COMPILE macro to mark format strings that should be compiled at compile-time.\\n\\n- Defines data structures like compiled_string and is_compiled_format to represent compiled format strings.\\n\\n- Implements compile-time parsing and compilation of format strings into efficient compiled representations using constexpr functions and templates.\\n\\n- Defines basic building blocks like text, code_unit, field that format parts of the string.\\n\\n- Parses format specifiers and argument identifiers at compile-time.\\n\\n- Concatenates parsed parts back into a single compiled representation.\\n\\n- Exports functions that take compiled formats and format arguments to efficiently format at runtime without parsing overhead.\\n\\nKey functions:\\n\\n- compile - compiles a format string into the compiled representation\\n- format/format_to - format using a compiled format at runtime  \\n- formatted_size - get size without formatting\\n- print - print to file/stdout\\n- FMT_COMPILE - marks format strings for compilation\\n\\nSo in summary, it enables efficient compile-time formatting by parsing format strings at compile-time into compiled representations.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/test/test-assert.h\&quot;:\&quot;This file contains test assertions for the formatting library (fmt).\\n\\nKey functions:\\n\\n- FMT_ASSERT: A macro that checks a condition and throws an assertion_failure exception if it fails, with the given message.\\n\\n- throw_assertion_failure: A function called by FMT_ASSERT to actually throw the exception. This avoids GCC warnings about throwing from a destructor.\\n\\n- assertion_failure: A class that derives from std::logic_error and is thrown on assertion failures. \\n\\n- EXPECT_ASSERT: A macro that expects an assertion failure from the given statement, matching the expected message. This is used in tests to verify assertions fail as expected.\\n\\nSo in summary, it provides test-friendly versions of assertions that throw exceptions on failure, which can then be expected and verified in tests using macros like EXPECT_ASSERT. This allows writing tests for code that uses FMT_ASSERT to check pre/post conditions.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/test/gtest/gtest/gtest-spi.h\&quot;:\&quot;This file contains utilities for testing Google Test itself and code that uses Google Test.\\n\\nKey things it provides:\\n\\n- ScopedFakeTestPartResultReporter class - Used to intercept and record Google Test failure reporting. This allows failures to be captured and verified when testing Google Test or code that uses it.\\n\\n- EXPECT_FATAL_FAILURE and EXPECT_FATAL_FAILURE_ON_ALL_THREADS macros - Verify a statement causes a fatal failure with a given substring in the failure message.\\n\\n- EXPECT_NONFATAL_FAILURE and EXPECT_NONFATAL_FAILURE_ON_ALL_THREADS macros - Verify a statement causes a non-fatal failure with a given substring. \\n\\n- SingleFailureChecker class - Used by the above macros to verify exactly one failure occurred with the expected type and substring.\\n\\nSo in summary, it provides utilities for mocking/intercepting Google Test\\u0027s failure reporting so failures can be verified when testing Google Test itself or code that builds on it. The macros make it easy to assert statements cause expected fatal or non-fatal failures.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/format.h\&quot;:\&quot;This file contains the core functionality for formatting and printing in the fmt library. Here are some of the key things it does:\\n\\n- Defines format specifications like width, precision, alignment, etc. These are used to control how values are formatted.\\n\\n- Defines formatters for common C++ types like integers, floats, strings, etc. Formatters specify how a type is formatted according to the format specs.\\n\\n- Implements formatting of values by writing them to an output iterator using the appropriate formatter. This is done by the `write()` functions.\\n\\n- Parses format strings and extracts format arguments. This is used for formatted printing.\\n\\n- Defines utilities for formatting things like pointers, enums, groups of digits, etc. \\n\\n- Implements formatting of user-defined types by defining formatters for them.\\n\\n- Defines formatting of values with nested formatting like `{:{fmt}}`.\\n\\n- Implements formatting of system errors and exceptions.\\n\\n- Defines formatting of common types like integers, floats, strings, pointers, etc. \\n\\n- Defines formatting of collections like ranges and join views.\\n\\n- Implements core formatting functions like `format()`, `print()`, `vformat()`, etc that tie everything together.\\n\\nSo in summary, this file provides the core implementation of value formatting and printing according to format specifications for the fmt library. It handles both built-in and user-defined types.\&quot;,\&quot;/cmake-build-debug/.cmake/api/v1/reply/cache-v2-84c5353ae0e8f7df1125.json\&quot;:\&quot;This file contains the CMake cache for a CMake project. The CMake cache stores important configuration values that CMake uses to generate build files and projects.\\n\\nSome key things this file does:\\n\\n- Stores configuration values that were set during the last CMake run, like CMAKE_BUILD_TYPE, CMAKE_INSTALL_PREFIX, compiler/linker flags, etc. These values persist between CMake runs.\\n\\n- Provides information about the CMake, compiler, and toolchain used to generate the build files. Things like CMAKE_COMMAND, CMAKE_CXX_COMPILER, CMAKE_MAKE_PROGRAM are stored here. \\n\\n- Stores information about third party libraries/modules that were found or configured, like FMT_SOURCE_DIR, FMT_INCLUDE_DIR, etc. \\n\\n- Contains internal CMake variables used during the generation process, like CMAKE_NUMBER_OF_MAKEFILES.\\n\\nKey functions:\\n\\n- Persists configuration values between CMake runs \\n- Provides information to regenerate identical build files\\n- Stores build configuration for third party libraries\\n- Acts as a central repository of all configuration details used by CMake\\n\\nSo in summary, the CMake cache file stores all the important configuration values, toolchain details, and build settings required for CMake to regenerate the same build files across multiple invocations.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/format-inl.h\&quot;:\&quot;This file contains the implementation details for the formatting library fmt. Some key things it does:\\n\\n- Defines utility functions used throughout the library like is_printable(), to_decimal(), etc. These implement core formatting logic.\\n\\n- Defines the formatter class template and specializations for common types like bigints. These control how types are formatted. \\n\\n- Defines vformat() and related functions for formatting with arguments. These are the main entry points for formatting.\\n\\n- Defines printing functions like vprint(), print() for writing formatted output.\\n\\n- Defines classes and functions for caching powers of 10, decimal conversion, UTF encoding, etc. These implement numeric and string formatting optimizations.\\n\\n- Defines reporting functions for errors like format_error_code(), report_error().\\n\\n- Defines detail namespaces and classes that contain implementation details hidden from public API.\\n\\nKey functions include:\\n\\n- is_printable() - Checks if a codepoint is printable\\n- to_decimal() - Converts a binary floating point number to a decimal representation \\n- vformat() - Formats a string with arguments\\n- vprint() - Prints formatted output to a file\\n- format_error_code() - Reports formatting errors\\n- get_cached_power() - Caches powers of 10 for decimal conversion\\n\\nSo in summary, it contains the core logic for formatting different types of data to strings.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/chrono.h\&quot;:\&quot;This file provides date and time formatting functionality for the fmt formatting library.\\n\\nSome key things it does:\\n\\n- Defines types like weekday, year_month_day that are needed for chrono formatting.\\n\\n- Provides formatters for common chrono types like std::tm, std::chrono::duration, std::chrono::time_point that handle parsing format strings and formatting values.\\n\\n- Defines helper classes like tm_writer that handle low-level formatting of std::tm values according to a format string.\\n\\n- Provides utilities for working with durations like converting to seconds, milliseconds, formatting values and units.\\n\\n- Handles locale-aware formatting by using std::locale facets.\\n\\n- Parses format strings according to the same syntax used by std::strftime and handles each format directive.\\n\\n- Supports alternative numeric representations in some locales.\\n\\n- Handles special values like NaN, infinity, and duration precision.\\n\\n- Provides safe conversions between duration types to avoid overflow.\\n\\nSome key functions:\\n\\n- parse() - Parses format strings \\n- format() - Main formatting function for formatters\\n- tm_writer - Low level std::tm formatting\\n- format_duration_value/unit - Format duration values and units\\n- safe_duration_cast - Safe conversions between durations\\n- localtime/gmtime - Thread-safe localtime/gmtime wrappers\\n\\nSo in summary, it provides all the core date/time formatting functionality needed for the fmt library.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/test/mock-allocator.h\&quot;:\&quot;This file defines mock classes for allocators that can be used in unit tests for code that uses allocators.\\n\\nKey things:\\n\\n- mock_allocator is a template class that mocks an allocator for a type T. It uses Google Mock macros to mock the allocate and deallocate methods.\\n\\n- allocator_ref is a wrapper class that holds a reference to an allocator. It forwards allocate and deallocate calls to the underlying allocator. \\n\\n- allocator_ref is meant to be used in place of the actual allocator type to allow injecting a mock allocator.\\n\\nKey functions:\\n\\n- mock_allocator::allocate - Mocks the allocate method \\n- mock_allocator::deallocate - Mocks the deallocate method\\n- allocator_ref::allocate - Forwards allocate calls to underlying allocator\\n- allocator_ref::deallocate - Forwards deallocate calls to underlying allocator\\n\\nSo in summary, it provides mock allocator classes that can be used to test code that depends on allocators, by injecting mock allocators and asserting on calls to allocate/deallocate.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/ChangeLog.md\&quot;:\&quot;This file contains the changelog for the fmt formatting and output library. Some key things it documents:\\n\\n- Version history and release notes for each version of fmt. This allows users to see what changed between releases.\\n\\n- New features and functionality added in each release, such as support for new data types, additional format specifiers, performance improvements, etc. \\n\\n- Bug fixes and resolved issues for each release.\\n\\n- Documentation improvements and updates.\\n\\n- Build system and test improvements.\\n\\n- Compatibility fixes for additional compilers/platforms.\\n\\n- Warning fixes and code cleanups.\\n\\nSome of the key functions and features documented in the changelog include:\\n\\n- Compile-time format string checks \\n- Iterator support for formatting\\n- format_to_n for limiting output length\\n- formatted_size for computing output size\\n- make_format_args for capturing format arguments\\n- Support for user-defined types\\n- Performance optimizations\\n- New color/styling output API\\n- Chrono formatting for dates/times\\n- Compile-time formatting capabilities\\n- Support for additional data types like tuples, ranges, etc.\\n\\nSo in summary, this file serves as the central changelog and release notes for the fmt library, documenting changes, improvements and fixes across its various releases. It provides useful information for both library users and developers.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/doc/_templates/search.html\&quot;:\&quot;This file defines the template for the search page in Sphinx documentation.\\n\\nKey functions:\\n\\n- Inherits from the base layout template \\n- Sets the page title to \\\&quot;Search\\\&quot;\\n- Includes the JavaScript search tools script\\n- Defines a JavaScript block to load the search index\\n- Displays a header and intro text for the search functionality\\n- Renders the search form \\n- Checks if a search was performed and displays results\\n- Loops through search results and outputs the href, caption and context for each\\n- Displays a \\\&quot;no results\\\&quot; message if no matches are found\\n\\nIn summary, it provides the HTML structure and template logic to display the search form, perform searches, and output any matching results from the documentation index. This allows users to search through the generated documentation from the Sphinx build.\&quot;,\&quot;/table/DataType.h\&quot;:\&quot;This file defines a DataType that can represent different data types in a table using std::variant.\\n\\nKey things:\\n\\n- DataType is an alias for std::variant, which can hold different types.\\n\\n- The types it can hold are std::string, int, float, bool, and std::monostate. \\n\\n- std::monostate is a dummy type that std::variant needs as a final type to represent no value.\\n\\n- This allows a single DataType variable to hold a value of string, int, float or bool dynamically without knowing the type ahead of time.\\n\\n- There are no functions defined - std::variant handles all the operations like get/set value, check type etc. behind the scenes.\\n\\nSo in summary:\\n\\n- Defines a DataType alias for std::variant to represent different table cell types\\n- DataType can hold string, int, float, bool or no value \\n- No functions defined - std::variant handles all operations\\n- Allows dynamic typing of table cell values without knowing type beforehand\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/ranges.h\&quot;:\&quot;This file defines support for formatting ranges (collections of elements) and tuples in fmt.\\n\\nKey things it does:\\n\\n- Defines is_range, is_tuple_like, is_tuple_formattable traits to determine if a type can be formatted as a range or tuple.\\n\\n- Defines range_formatter and formatter specializations for formatting ranges and tuples. This includes parsing format specifications and formatting the elements.\\n\\n- Defines utilities like range_begin, range_end, tuple_size, tuple_element to work with ranges and tuples.\\n\\n- Defines join() functions to format a tuple or initializer_list with separated elements.\\n\\nKey functions:\\n\\n- range_formatter - Formats a range by iterating over elements.\\n\\n- formatter\\u003cTuple\\u003e - Formats a tuple by iterating over elements. \\n\\n- join() - Returns a view that formats a tuple/list with separated elements.\\n\\n- is_range, is_tuple_like, is_tuple_formattable - Traits to determine if a type can be formatted as a range/tuple. \\n\\n- range_begin, range_end - Get begin/end of a range.\\n\\n- tuple_size, tuple_element - Get size and elements of a tuple.\\n\\nSo in summary, it adds support for formatting collections like ranges and tuples to fmt.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/support/compute-powers.py\&quot;:\&quot;This Python file computes and prints out the significands and exponents of powers of 10 from 10^-348 to 10^340.\\n\\nKey things it does:\\n\\n- Defines a class called fp to hold the significand (f) and exponent (e) values for each power\\n- Loops through exponents from min_exponent to max_exponent, incrementing by step\\n- For each exponent:\\n  - Computes the value of 10^exp \\n  - Rounds it to a 64-bit binary significand \\n  - Stores the significand and exponent in an fp object\\n  - Appends the fp object to a powers list\\n- Prints out the significands of each power in hex format\\n- Prints out the exponents of each power  \\n- Prints the maximum difference between consecutive exponents\\n\\nKey functions:\\n\\n- range() to generate the exponents to iterate over\\n- 10**exp to compute the power values \\n- format() to convert numbers to binary and round\\n- print() to output the results\\n- fp class to store significand/exponent pairs\\n\\nSo in summary, it efficiently computes a table of normalized floating point powers of 10 over a wide exponent range.\&quot;,\&quot;/table/Table.cpp\&quot;:\&quot;This Table.cpp file defines a Table class that represents a database table.\\n\\nThe key functions it contains are:\\n\\n- insert() - Adds a new row of data to the table from a map of column names to values\\n- display() - Prints out the column names and all rows of data \\n- createTable() - Initializes the table structure by adding columns from names and types\\n- mapColumnType() - Helper function to map a column type string to a DataType \\n- load() - Loads data from a file path into the table\\n- save() - Saves the table data out to a file\\n- update() - Updates existing rows in the table \\n- createRelation() - Creates relationships between tables \\n- deleteRow() - Deletes a row from the table\\n- deleteTable() - Deletes the entire table\\n\\nSo in summary, it defines a Table class that can represent a database table structure, insert/select rows of data, and perform basic CRUD (create, read, update, delete) operations on the table and rows. It also has functions for initializing the table schema and saving/loading from files.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/color.h\&quot;:\&quot;This file defines color support for the formatting library fmt.\\n\\nKey things it does:\\n\\n- Defines enum classes for colors (color) and terminal colors (terminal_color)\\n- Defines enum class for text emphasis styles (emphasis)\\n- Defines struct rgb for storing RGB color values\\n- Defines struct color_type to represent either an RGB or terminal color\\n- Defines class text_style to represent a text formatting style with colors and emphasis\\n- Defines functions like fg(), bg() to create text styles from colors\\n- Defines functions like print(), format() to format and output colored text\\n- Defines formatting support for styled arguments with color/emphasis\\n- Defines styled() function to create styled arguments\\n\\nKey functions:\\n\\n- fg(), bg() - create text styles from foreground/background colors\\n- print(), format() - format and output colored text \\n- vformat(), vformat_to() - low-level formatting functions\\n- text_style - represents a text formatting style\\n- color_type - represents a color \\n- styled() - create styled arguments for formatting\\n- make_foreground_color(), make_background_color() - create ANSI escape codes\\n\\nSo in summary, it provides types and functions for defining and applying text styles like colors and emphasis to formatted output using ANSI escape codes.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/os.h\&quot;:\&quot;This file (fmt/os.h) contains OS-specific functionality for the formatting library fmt.\\n\\nSome key things it does:\\n\\n- Defines platform-specific macros like FMT_POSIX, FMT_SYSTEM, etc. to abstract differences between POSIX and Windows.\\n\\n- Defines cstring_view, a reference to a null-terminated string that can be constructed from C strings or std::strings.\\n\\n- Defines buffered_file and file classes to represent file handles and do buffered I/O.\\n\\n  - buffered_file constructor opens a file\\n  - file constructor opens a file by descriptor\\n  - read(), write() methods for file I/O\\n  \\n- Wrappers for Windows errors - windows_error(), report_windows_error()\\n\\n- say() function to use OSX\\u0027s \\\&quot;say\\\&quot; command \\n\\n- ostream class for fast unbuffered output to files\\n\\n  - Constructed with output_file() function\\n  - print() method formats and writes to underlying file\\n\\n- Various utility functions - system_category(), getpagesize(), etc.\\n\\nSo in summary, it provides OS abstractions and file I/O functionality on top of the formatting library in fmt.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/.github/issue_template.md\&quot;:\&quot;This file is an issue template for the fmt (formatting library) project on GitHub. \\n\\nWhen a new issue is created in the fmt repository on GitHub, this template will be pre-populated in the issue description to provide guidance to the person submitting the issue.\\n\\nThe key purpose and functions of this file are:\\n\\n- Provide instructions to ensure the reported issue reproduces on the current master branch before submitting. This helps avoid reporting issues that may have already been fixed.\\n\\n- Suggest including a minimal code sample to reproduce the issue on Compiler Explorer if possible. Compiler Explorer allows live debugging of code across different compilers/versions, which can help the maintainers diagnose and fix the problem.\\n\\n- Acts as a template to structure the issue report and capture relevant details like steps to reproduce, expected vs actual behavior, system configuration etc. This helps the maintainers understand and address the problem more efficiently. \\n\\n- Helps improve the quality of issues reported by guiding the submitter on what information is needed. This saves the maintainers\\u0027 time chasing for more details in the issue discussion.\\n\\nSo in summary, it provides guidelines and templates to streamline the issue reporting process for the fmt project on GitHub.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/doc/_static/bootstrap.min.js\&quot;:\&quot;This file is the main JavaScript file for Bootstrap, a popular front-end framework. Some key things it does:\\n\\n- Initializes and provides jQuery/Popper.js dependencies\\n- Defines plugins/components as classes that extend the base Plugin class (e.g. Alert, Button, Modal, etc.)\\n- Registers plugins/components with jQuery/Popper for jQuery-like usage (e.g. $.fn.modal.Constructor \\u003d Modal)\\n- Defines common utility functions like on(), off(), trigger(), etc. that plugins can use\\n- Defines the base Plugin class that all plugins extend, with common methods like _getConfig(), dispose(), etc.\\n\\nSome key functions/classes:\\n\\n- Plugin - The base class that all plugins extend\\n- on/off - Event handlers \\n- trigger - Trigger events\\n- Alert - Alert plugin\\n- Button - Button plugin\\n- Carousel - Carousel plugin\\n- Collapse - Collapse plugin\\n- Dropdown - Dropdown plugin  \\n- Modal - Modal plugin\\n- Offcanvas - Offcanvas plugin\\n- Popover - Popover plugin\\n- ScrollSpy - Scroll spy plugin\\n- Tab - Tab plugin\\n- Toast - Toast plugin  \\n- Tooltip - Tooltip plugin\\n\\nSo in summary, it initializes dependencies, defines common utilities, and registers all the major Bootstrap plugins/components as classes for jQuery-like usage across the framework.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/test/gtest-extra.h\&quot;:\&quot;This file defines additional custom Google Test assertions for testing formatting library code.\\n\\nKey functions:\\n\\n- FMT_TEST_THROW_: Macro that tests if a statement throws the expected exception with the expected message.\\n\\n- EXPECT_THROW_MSG: Convenience macro that calls FMT_TEST_THROW_ to test for exception. \\n\\n- system_error_message: Helper function to generate the expected error message string for system_error exceptions.\\n\\n- EXPECT_SYSTEM_ERROR: Macro to test if a statement throws a system_error with the expected error code and message.\\n\\n- output_redirect: Class that redirects output from a file to a pipe, so the output can be captured and tested. \\n\\n- FMT_TEST_WRITE_: Macro that uses output_redirect to test if a statement writes expected output to a file. \\n\\n- EXPECT_WRITE: Convenience macro that calls FMT_TEST_WRITE_ to test file output.\\n\\n- suppress_assert: Class that suppresses Windows assertions, so POSIX functions return errors instead of crashing on Windows.\\n\\n- EXPECT_SYSTEM_ERROR_NOASSERT: Version of EXPECT_SYSTEM_ERROR that uses suppress_assert.\\n\\n- read: Helper function to read from a file.\\n\\n- EXPECT_READ: Macro to test reading expected content from a file.\\n\\nSo in summary, it defines macros and helpers for testing exceptions, file output, and file reading in formatting library tests.\&quot;,\&quot;/cmake-build-debug/CMakeFiles/3.27.8/CompilerIdC/CMakeCCompilerId.c\&quot;:\&quot;This file is used to detect the compiler and platform being used to compile a C program. It defines macros and strings that provide information about the compiler, platform, architecture, and language standards.\\n\\nKey functions/purposes:\\n\\n- Defines macros like COMPILER_ID, PLATFORM_ID, ARCHITECTURE_ID to identify the compiler, platform, and architecture\\n- Parses compiler-specific macros like __INTEL_COMPILER to determine compiler version\\n- Constructs string literals like info_compiler, info_platform, info_version that encode the identification information\\n- Defines C_VERSION and language standard macros based on __STDC__ and language features\\n- main() function simply prints out all the identification strings \\n\\nSo in summary, it is a compiler identification header that allows a C program to detect details about the compiler and build environment by including this file and accessing the macros and strings it defines. This information can be useful for configuration, debugging, etc. It works across many different compilers on different platforms.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/ostream.h\&quot;:\&quot;This file provides support for formatting and printing to std::ostream streams like std::cout in the formatting library fmt.\\n\\nKey things it does:\\n\\n- Defines formatter classes like basic_ostream_formatter that allow formatting objects that can be streamed to ostream with operator\\u003c\\u003c.\\n\\n- Defines streamed() function that creates a view wrapping a value to be formatted via streaming. \\n\\n- Defines format_value() function that formats a value to a buffer using an ostream.\\n\\n- Defines write_buffer() to write a buffer to an ostream.\\n\\n- Defines vprint() function that formats to a buffer and writes to ostream, handling UTF-8 detection. \\n\\n- Defines print() and println() convenience functions that format and print to ostream.\\n\\nKey functions:\\n\\n- streamed() \\n- format_value()\\n- write_buffer()\\n- vprint()\\n- print()\\n- println()\\n\\nSo in summary, it provides the core functionality to format values and print the results to std::ostream streams like cout using the formatting syntax and APIs from fmt.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/support/rtd/index.rst\&quot;:\&quot;This file is an index.rst file that is used for Read the Docs documentation generation for the fmt library.\\n\\nSome key things about this file:\\n\\n- It is located in the _deps/fmt-src/support/rtd directory, which indicates it is likely being used to configure documentation builds for the fmt dependency.\\n\\n- The contents redirect the user to the main fmt documentation website at fmt.dev, rather than trying to build/host the docs locally. This is common for libraries to point to their hosted documentation rather than rebuilding it for each project.\\n\\n- index.rst is a common name for the root/index file that Read the Docs uses as the starting point to build out the documentation structure and navigation. \\n\\n- By containing only a redirect, this file ensures any documentation built from this source code dependency is pointed to the canonical online documentation rather than trying to rebuild it locally.\\n\\nSo in summary, this file:\\n\\n- Acts as the root index file for Read the Docs documentation builds\\n- Redirects the user to the online fmt documentation rather than rebuilding docs locally \\n- Avoids duplicating documentation by centralizing it on fmt.dev\\n\\nThe key function is to redirect the user to the intended documentation source rather than rebuilding documentation unnecessarily for each project.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/support/build-docs.py\&quot;:\&quot;This Python script builds and publishes the documentation for the fmt library.\\n\\nKey functions:\\n\\n- build_docs() - Builds the documentation HTML files by calling the build.py script in the doc directory. Returns the path to the built HTML.\\n\\n- rmtree_if_exists() - Removes a directory if it exists, ignoring errors if the directory doesn\\u0027t exist. Used to clean up before cloning/copying. \\n\\n- clone_repo() - Clones the fmtlib.github.io repository to publish the docs to.\\n\\n- copy_docs() - Copies the built HTML files to the dev directory of the cloned repo. \\n\\n- commit_and_push() - Commits the updated docs, pushes to GitHub with authentication if running in CI, prints output.\\n\\nSo in summary, it builds the local docs, clones the GitHub Pages repo, copies the built files over, commits and pushes the changes to publish the updated documentation. It also has CI-specific logic to only run on master and push with the GitHub key if running in a CI environment.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/test/posix-mock.h\&quot;:\&quot;This file (posix-mock.h) contains mocks/stubs of various POSIX/system functions for testing purposes in the fmt library.\\n\\nThe key things it does:\\n\\n- Defines a test namespace to contain the mocks.\\n\\n- Defines typedefs for size_t and ssize_t to match the platform.\\n\\n- Mocks/stubs out various POSIX/system functions like:\\n  - open, close, read, write, pipe\\n  - fopen, fclose, fileno \\n  - sysconf, GetFileSize\\n  - dup, dup2\\n  - fdopen\\n\\n- Puts the mocks/stubs behind a FMT_SYSTEM macro so they can be used in place of the real system calls during testing.\\n\\n- On non-Windows platforms, also mocks struct stat and locale functions.\\n\\nSo in summary, it provides mocks/stubs of various low-level system/file I/O functions to allow testing code that uses those functions without needing a real OS/environment. The mocks are wrapped in a test namespace and FMT_SYSTEM macro to be used during testing.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/test/gtest/gmock/gmock.h\&quot;:\&quot;This file contains definitions and implementations for Google Mock matchers.\\n\\nSome key things it does:\\n\\n- Defines macros like MATCHER, MATCHER_P, etc to allow defining custom matchers. These macros generate boilerplate code for implementing MatcherInterface.\\n\\n- Implements common polymorphic matchers like _, Eq(), Not(), etc. These use templates to work with any argument type. \\n\\n- Defines classes like MatcherCastImpl, TupleMatches, etc to implement core matcher functionality like casting, matching tuples, etc.\\n\\n- Implements common value matchers like HasSubstr(), StartsWith(), EndsWith() etc that work on string-like types.\\n\\n- Defines CardinalityInterface and related classes that implement call cardinalities for expectations.\\n\\nSome key functions:\\n\\n- MatchAndExplain() - Core matching function that also explains failures. Implemented by all matchers.\\n\\n- DescribeTo(), DescribeNegationTo() - Describe the matcher and its negation.\\n\\n- MatcherCast() - Safely cast a matcher to work with a different type.\\n\\n- TupleMatches() - Match a tuple of matchers against a value tuple.\\n\\n- MATCHER(), MATCHER_P() - Macros used to define custom matchers.\\n\\n- ON_CALL(), EXPECT_CALL() - Macros used to define expectations and default actions.\\n\\nSo in summary, this file provides the core matcher and expectation implementation that Google Mock is built upon.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/test/fuzzing/README.md\&quot;:\&quot;This file provides instructions for running the fuzzers that are part of the fmt library test suite locally.\\n\\nKey points:\\n\\n- It describes a helper script (build.sh) that builds the fuzzers, but notes it has only been tested on Linux so far. \\n\\n- It provides sample CMake and build commands that should work cross-platform to build the fuzzers using clang. This configures the build with sanitizers like fuzzer.\\n\\n- It explains how to execute a built fuzzer binary, like fuzzer_chrono_duration, providing an output directory for found issues.\\n\\n- It mentions some environment variables like UBSAN_OPTIONS that can be set to configure sanitizer behavior while running the fuzzers.\\n\\nSo in summary, this file:\\n\\n- Provides build instructions to compile the fuzzers locally\\n- Explains how to configure the build for fuzzing \\n- Shows how to execute a built fuzzer binary\\n- Mentions some environment variables useful for fuzzing\\n\\nThe key functions are building and running the fuzzers to test the fmt library.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/core.h\&quot;:\&quot;This file defines the core functionality of the fmt formatting library. Some key things it does:\\n\\n- Defines common types like basic_string_view, format_specs, etc that are used throughout the library.\\n\\n- Defines core classes like basic_format_context, basic_format_arg, basic_format_args that represent formatting contexts, arguments, and argument lists. \\n\\n- Defines type traits like is_formattable, mapped_type_constant, etc to map C++ types to their internal representation.\\n\\n- Defines parsing functions like parse_format_specs, parse_replacement_field that parse format strings.\\n\\n- Defines format string checking functions like format_string_checker that validate format strings at compile-time. \\n\\n- Defines formatters for built-in types like integers, floats, strings that handle formatting of those types.\\n\\n- Defines formatting functions like vformat, format, format_to, format_to_n that do the actual formatting.\\n\\n- Defines printing functions like print, println that format and output to stdout/files.\\n\\nSome key functions:\\n\\n- format - formats and returns a string\\n- format_to - formats and writes to an output iterator\\n- vformat - type-erased formatting function \\n- print/println - formats and prints to stdout/files\\n- parse_format_specs - parses format specifiers\\n- format_string_checker - checks format strings at compile-time\\n\\nSo in summary, this file defines the core types, classes, traits and functions that implement formatting in the fmt library.\&quot;,\&quot;/table/TableRow.h\&quot;:\&quot;This file defines a TableRow struct that represents a row in a table.\\n\\nKey things:\\n\\n- It defines a TableRow struct that will hold the data for a single row.\\n\\n- The row data is stored in a std::map with column names (std::string) as keys and DataType values. DataType is some defined type that can hold different data types.\\n\\n- It has a private std::map member called row to store the actual data. \\n\\n- It has a public display() method that will likely print out the row data. This is the only function declared so far.\\n\\nSo in summary:\\n\\n- Defines a TableRow struct to represent a single row\\n- Uses a map to store column name -\\u003e data mappings \\n- Stores the data in a private row member\\n- Has a public display() function to output the row\\n\\nThe key aspects are it structures the row data, stores it privately, and provides an interface to display the row contents.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/args.h\&quot;:\&quot;This file defines classes and functions for handling dynamic argument lists in the fmt formatting library.\\n\\nKey things:\\n\\n- detail::dynamic_arg_list - Stores arguments dynamically as they are added. Each argument is stored in a typed node.\\n\\n- dynamic_format_arg_store - Stores formatting arguments that can be passed to formatting functions. It has a vector to store basic arguments and a dynamic_arg_list to store arguments that don\\u0027t fit in the vector.\\n\\n- push_back() functions - Add an argument to the dynamic store, copying if needed. Overloads for regular arguments, references, and named arguments.\\n\\n- clear() - Erases all elements from the store. \\n\\n- reserve() - Reserves space in the storage vectors.\\n\\nSo in summary, it provides dynamic storage and management of formatting arguments that can grow as needed, to be passed to formatting functions like vformat(). The key classes are dynamic_arg_list for dynamic storage and dynamic_format_arg_store as the main API class.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/support/AndroidManifest.xml\&quot;:\&quot;This file is an Android manifest file for the fmt library.\\n\\nThe Android manifest file provides essential information about an Android application to the Android system, defining components of the app and declaring permissions needed.\\n\\nKey functions of this manifest file:\\n\\n- Declares the package name for the fmt library as \\\&quot;dev.fmt\\\&quot;. This uniquely identifies the library and all its components.\\n\\n- No other components like activities, services, receivers etc are declared, as fmt is a library and not a standalone app. Libraries generally have minimal manifest files. \\n\\n- Does not declare any permissions, as the library likely does not need any special permissions to function. \\n\\n- Tells the Android system this is a library project and provides basic identification for it. The actual app projects using this library would have their own more complete manifest files declaring how they use this library.\\n\\n- Minimal manifest allows fmt library to be included and used seamlessly by other Android apps without requiring any special permissions or declarations in the including app\\u0027s manifest.\\n\\nSo in summary, it is a minimal manifest that identifies the fmt library package for the Android system.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/doc/basic-bootstrap/layout.html\&quot;:\&quot;This file is the master layout template for Sphinx themes. It defines the overall structure and common elements of HTML pages generated by Sphinx.\\n\\nKey functions:\\n\\n- Defines the basic HTML document structure with doctype, head, body etc.\\n\\n- Includes common page elements like navigation bars, sidebars, scripts, stylesheets etc using macros. \\n\\n- Renders the page title, metadata, links etc using blocks.\\n\\n- Defines the overall page layout with common sections like header, content, footer. \\n\\n- Content block allows embedding the generated documentation body. \\n\\n- Sidebar block conditionally includes the sidebar macro.\\n\\n- Relbar macros generate the related links navigation bars. \\n\\n- Script and CSS macros include necessary scripts and styles.\\n\\n- Blocks allow customizing elements like titles, headers, footers etc in child templates.\\n\\n- Sets variables like path prefixes, titles, metadata needed for template rendering.\\n\\nSo in summary, it provides the core scaffolding and common infrastructure for Sphinx HTML theme templates to build upon.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/xchar.h\&quot;:\&quot;This file (fmt/xchar.h) provides support for wide character (wchar_t) and exotic character types in the formatting library FMT.\\n\\nSome key things it does:\\n\\n- Defines wide character string and formatting context types like wstring_view, wformat_parse_context, wformat_context, etc. analogous to the basic string/context types.\\n\\n- Provides wide character formatting functions like format(), vformat(), format_to(), etc. that work similarly to the basic string versions but for wchar_t. \\n\\n- Adds support for locale-aware formatting of wide characters.\\n\\n- Defines join() and to_string() functions that work on wide character strings. \\n\\n- Prints to files/stdout using wide character strings via vprint(), print(), println().\\n\\n- Converts values to wide strings using to_wstring().\\n\\n- Supports exotic character types like char16_t, char32_t via template specializations and enables formatting for them.\\n\\nSo in summary, it extends the core FMT formatting functionality to support wide characters and additional character types beyond char. The key functions allow formatting, parsing, printing wide character strings.\&quot;,\&quot;/table/TableRow.cpp\&quot;:\&quot;This file defines a class called TableRow that represents a row in a table.\\n\\nThe key things it does:\\n\\n- Defines a TableRow class with a member variable called \\\&quot;row\\\&quot; which is a map that stores the column name and value pairs for the row.\\n\\n- Defines a DataTypeToString struct that overloads the () operator to convert different data types (string, int, float, bool) to a string for display purposes. \\n\\n- Implements a display() method that iterates through the row map, uses the DataTypeToString struct to convert each value to a string, and prints it formatted with 20 character width padding.\\n\\nSo in summary:\\n\\n- It defines a TableRow class to represent a table row\\n- Stores column name and value pairs in a map \\n- Defines a helper struct to convert types to strings\\n- Implements a display() method to print out the row formatted\\n\\nThe key function is display() which handles printing out the row contents in a formatted way.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/CONTRIBUTING.md\&quot;:\&quot;This file contains guidelines for contributing to the fmt library.\\n\\nSome key points:\\n\\n- By submitting a pull request or patch, you are agreeing to license your contribution under the fmt license and agree to future changes to the licensing.\\n\\n- All C++ code must adhere to the Google C++ Style Guide, with some exceptions noted for allowing exceptions and using snake_case naming. \\n\\n- All documentation must adhere to the Google Developer Documentation Style Guide.\\n\\n- It provides information on the code style and formatting guidelines that contributors need to follow when submitting code changes to the fmt library. \\n\\n- It also covers licensing terms that contributors agree to by submitting code to the project.\\n\\nSo in summary, this CONTRIBUTING file outlines the contribution process and guidelines for code style, documentation style, and licensing that contributors need to follow when submitting code to the fmt library project.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/test/scan.h\&quot;:\&quot;This file defines a scanning API for formatting library (fmt) as a proof of concept.\\n\\nKey things it does:\\n\\n- Defines scan_buffer and related classes like string_scan_buffer and file_scan_buffer to represent input buffers for scanning.\\n\\n- Defines scan_iterator, scan_context and related classes to represent the scanning state.\\n\\n- Defines scan_arg to represent scan arguments. \\n\\n- Defines scanners for built-in types like integers, strings etc. Also allows custom scanners.\\n\\n- Defines scan_handler to parse format strings and handle scanning.\\n\\n- Defines vscan() function to perform scanning given a buffer and arguments.\\n\\nKey functions:\\n\\n- scan() functions to scan from a string, input range or file into arguments.\\n\\n- make_scan_args() to create argument array from references.\\n\\n- scan_buffer classes like string_scan_buffer to represent different input sources. \\n\\n- read() functions to extract values of different types from the input.\\n\\n- parse_scan_specs() to parse format specifiers like width/precision.\\n\\n- scan_handler::on_* methods to handle parsing format strings during scanning.\\n\\nSo in summary, it provides infrastructure and functions to implement formatted scanning from input similar to formatted printing with fmt.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/doc/syntax.rst\&quot;:\&quot;This file defines the format string syntax used by fmt formatting library.\\n\\nSome key things it does:\\n\\n- Defines the grammar for format strings used by fmt::format() and fmt::print(). Format strings contain replacement fields surrounded by {} that are replaced with argument values.\\n\\n- Describes the syntax for replacement fields, including optional argument id and format specifier separated by :.\\n\\n- Defines the format specifier mini-language including options like width, precision, alignment, padding, type specifiers etc. \\n\\n- Provides examples of common format specifiers like d, x, f etc and how they map to printf specifiers.\\n\\n- Describes chrono format specifiers for formatting dates, times etc. \\n\\n- Describes format specifiers for range types.\\n\\n- Provides many examples of format strings.\\n\\nSo in summary, it defines the format string syntax and semantics that are at the core of how fmt works for formatting values. The key functions would be fmt::format() and fmt::print() which take format strings and arguments to generate formatted output.\&quot;,\&quot;/cmake-build-debug/.cmake/api/v1/reply/target-2324Z_19_s26525_FK-Debug-4fce5eceb27346e053a3.json\&quot;:\&quot;This JSON file contains build information for a C++ executable target called \\\&quot;2324Z_19_s26525_FK\\\&quot; in CMake.\\n\\nSome key things it contains:\\n\\n- Artifacts - The generated executable and PDB files\\n- Backtrace graph - The CMake commands and files that were used to build the target\\n- Compile groups - Information about compilation like includes, source files, language standard\\n- Dependencies - Any external library dependencies \\n- Sources - The source files grouped by compile unit and source group\\n- Link information - Linker flags, libraries used\\n\\nSome key functions:\\n\\n- Provides a machine-readable format for the build system to query target properties\\n- Allows tools to understand dependencies, compilation settings, artifacts produced\\n- Enables debugging/troubleshooting build issues by tracing back commands/files\\n- Provides metadata for IDEs to understand the project structure and configuration\\n- Standardizes retrieval of target build information across generators\\n\\nSo in summary, it exposes detailed build metadata for a target in a structured JSON format that tools and IDEs can consume programmatically.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/doc/contents.rst\&quot;:\&quot;This file is a contents file for documentation generated using Sphinx for the fmt (formatting) library.\\n\\nKey things about this file:\\n\\n- It is a reStructuredText (.rst) file, which is the file format used by Sphinx for documentation markup and structure.\\n\\n- The \\\&quot;contents\\\&quot; in the title indicates this file defines the top-level contents or structure of the documentation.\\n\\n- The \\\&quot;.. toctree::\\\&quot; directive generates a table of contents from the listed files. This allows Sphinx to automatically generate a navigation structure for the docs.\\n\\n- The listed files \\\&quot;usage\\\&quot;, \\\&quot;api\\\&quot;, and \\\&quot;syntax\\\&quot; are likely individual documentation files that will be included in the auto-generated TOC.\\n\\n- \\\&quot;maxdepth: 2\\\&quot; limits the nested levels that will be included in the TOC, in this case just the top-level files are included.\\n\\nSo in summary, the key functions of this file are:\\n\\n- Define the top-level contents/structure of the documentation \\n- Automatically generate a table of contents from the listed files\\n- Allow easy navigation between documentation files\\n\\nIt provides the starting point and navigation for the Sphinx-generated documentation for the fmt library.\&quot;,\&quot;/cmake-build-debug/.cmake/api/v1/reply/toolchains-v1-471bce94bfe13a5ea4fc.json\&quot;:\&quot;This JSON file contains toolchain information for CMake.\\n\\nKey functions:\\n\\n- It defines 3 toolchains (compilers):\\n  - GNU C compiler (gcc)\\n  - GNU C++ compiler (g++) \\n  - Windows resource compiler (windres)\\n\\n- For each toolchain it provides:\\n  - Compiler ID and path \\n  - Supported language \\n  - Source file extensions it can handle\\n\\n- It also defines the \\\&quot;implicit\\\&quot; settings for each compiler, like include paths, link paths, libraries etc. This provides the default configuration so CMake knows where to find headers and libraries without needing to specify.\\n\\n- The \\\&quot;version\\\&quot; field at the bottom defines the CMake API version used to generate this file.\\n\\nSo in summary, this file allows CMake to identify the available compilers on the system and their default configuration. It provides all the toolchain information CMake needs to correctly configure, build and link C/C++ projects for this environment.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/support/rtd/conf.py\&quot;:\&quot;This file is a Sphinx configuration file for Read the Docs (RTD), which is a service for hosting documentation.\\n\\nSome key things it does:\\n\\n- Sets the master_doc to \\u0027index\\u0027 - This tells Sphinx which document is the \\\&quot;main\\\&quot; document that will be the entry point for building the documentation.\\n\\n- Sets the html_theme to \\u0027theme\\u0027 - Specifies which theme to use for building the HTML output. This theme must be located in the current directory.\\n\\n- Sets html_theme_path to [\\\&quot;.\\\&quot;] - Tells Sphinx where to look for custom themes. The \\\&quot;.\\\&quot; means the current directory.\\n\\nSo in summary, this file:\\n\\n- Configures Sphinx for building docs targeted at RTD \\n- Sets the main/entry point document\\n- Specifies a custom HTML theme located in the current directory\\n- Allows Sphinx to find/use the custom theme directory\\n\\nThis allows the documentation to be built and styled properly for display on the RTD site using a custom theme defined locally.\&quot;,\&quot;/main.cpp\&quot;:\&quot;This C++ file is creating a simple database table using classes from a table library:\\n\\n- It includes the TableRow.h and Table.h header files which define the TableRow and Table classes.\\n\\n- The main() function is the entry point of the program. \\n\\n- It declares a std::string variable called command and initializes it to a SQL-like CREATE TABLE statement. \\n\\n- This statement defines a table called \\\&quot;blabla\\\&quot; with 3 columns - an integer id, string name, and string surname.\\n\\n- No other code is shown, but the intent is likely to:\\n\\n  1. Parse the command string \\n  2. Use the Table class to create a new table object \\n  3. Add TableRow objects to populate the table\\n  4. Potentially perform other CRUD (create, read, update, delete) operations\\n\\nKey functions that would be defined in the included header files:\\n\\n- TableRow class - represents a single row of data in the table\\n  - Constructor to initialize column values\\n\\n- Table class - represents the database table\\n  - Constructor to initialize the table \\n  - Functions to add/remove rows\\n  - Functions to retrieve/update rows by id\\n  - Other CRUD functions\\n\\nSo in summary, it is setting up a simple in-memory database table using C++ classes. The main purpose is likely to demonstrate basic CRUD operations on the table.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/support/docopt.py\&quot;:\&quot;This file implements a command line argument parser called docopt.\\n\\nKey things it does:\\n\\n- Parses a usage string and documentation to generate a pattern for matching arguments\\n- Tokenizes command line arguments \\n- Matches the tokens against the generated pattern\\n- Returns a dictionary of argument names and values\\n\\nKey functions:\\n\\n- parse_pattern - Parses the usage string and documentation into a pattern \\n- Tokens - Class for tokenizing command line arguments\\n- parse_argv - Parses command line tokens against the options pattern\\n- Pattern - Base class for nodes in the pattern tree\\n- LeafPattern/BranchPattern - Node classes for leaves/branches in pattern tree\\n- Required, Optional, etc - Pattern classes like required, optional, etc\\n- docopt - Main function that parses arguments and returns result dict\\n\\nSo in summary, it takes a usage string and documentation, generates a pattern from it, matches the command line tokens against that pattern, and returns a parsed result dictionary. The core is using a pattern tree to represent the possible argument structures.\&quot;,\&quot;/cmake-build-debug/.cmake/api/v1/reply/index-2024-01-15T14-51-15-0210.json\&quot;:\&quot;This file is a JSON response from CMake to a client (likely an IDE like CLion) requesting information about the CMake project.\\n\\nSome key things it provides:\\n\\n- Information about the CMake installation (version, paths to executables)\\n- The generator being used (Ninja)\\n- A list of available data objects (code model, cache, CMake files, toolchains) \\n- The versions of each data object\\n- A \\\&quot;reply\\\&quot; section that maps object names to the JSON files containing the data for each object\\n\\nThe main functions of this file are:\\n\\n1. Provide metadata about the CMake environment \\n2. Identify what specific data objects are available \\n3. Point the client to the JSON files containing the actual data for each object\\n\\nThis allows the client to discover what information CMake has generated and then load/parse the individual JSON files for things like the code model, cache values, etc. to integrate that data into its own UI and functionality.\\n\\nSo in summary, it acts as an index/manifest of the CMake-generated data available to the client for that particular project build.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/doc/usage.rst\&quot;:\&quot;This file documents how to use the fmt formatting library. Some key points:\\n\\n- It describes how to build the library from source using CMake. This allows integrating fmt as a subproject or finding an installed version.\\n\\n- It lists the header files needed to use fmt and where to get prebuilt releases. \\n\\n- It explains how to install the built library on Unix systems.\\n\\n- It provides examples of using fmt with different build systems like CMake, Meson, build2, etc. This allows integrating fmt into projects using these build tools.\\n\\n- It describes how to build the documentation using Doxygen and generate HTML docs.\\n\\n- It lists other package managers and platforms fmt supports like Conda, vcpkg, Homebrew, Android NDK etc. \\n\\nSo in summary, this file:\\n\\n- Documents how to build and install fmt \\n- Provides usage examples for different build systems\\n- Lists where to get prebuilt binaries\\n- Explains how to build/use docs\\n- Covers additional platforms and package managers\\n\\nThe key functions are to educate developers on how to integrate and use the fmt library within their own projects using common build systems and platforms. It serves as the main usage and integration guide.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/doc/api.rst\&quot;:\&quot;This file contains API documentation for the fmt formatting library.\\n\\nKey things it does:\\n\\n- Documents the main headers and what they provide (format.h, core.h, ranges.h, chrono.h, etc.)\\n\\n- Describes the core formatting functions like format(), print(), vformat()\\n\\n- Explains how to make user-defined types formattable via format_as() or formatter specializations \\n\\n- Documents utilities like format_args, format_context, format strings\\n\\n- Covers locale support, compile-time format string checks, named arguments\\n\\n- Documents formatting of standard library types like variants, optional, filesystem\\n\\n- Describes format string compilation with FMT_COMPILE\\n\\n- Documents terminal color/styling support\\n\\n- Covers std::ostream integration and printf formatting\\n\\n- Lists differences from C++20 std::format implementation\\n\\nSome key functions it documents include:\\n\\n- format(), print() \\n- format_as(), formatter\\u003c\\u003e\\n- format_args, format_context\\n- vformat(), format_to()\\n- join(), group_digits()\\n- streamed(), printf()\\n- fg(), bg(), styled()\\n- FMT_COMPILE\\n\\nSo in summary, this file provides API documentation and explains how to use the main features of the fmt formatting library.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/test/util.h\&quot;:\&quot;This file contains test utilities for the fmt formatting library.\\n\\nKey functions:\\n\\n- safe_sprintf - Safely formats a string into a buffer using snprintf. Handles Windows vs non-Windows variants.\\n\\n- open_buffered_file - Opens a file for reading and returns a buffered_file object.\\n\\n- safe_fopen - Safely opens a file for reading/writing, handling Windows specific behavior. \\n\\n- basic_test_string - Simple string class to use for test strings.\\n\\n- operator\\u003c\\u003c - Output stream operator for basic_test_string.\\n\\n- date - Simple date class for tests.\\n\\n- get_locale - Gets a locale by name, or the classic locale if not available.\\n\\nSo in summary, it provides various utilities for safely working with files, strings, locales for tests as well as a simple date class. The main purpose is to help write cross-platform formatting tests.\&quot;,\&quot;/cmake-build-debug/.cmake/api/v1/reply/directory-_deps.fmt-build-Debug-dd7b34a7b07e46720069.json\&quot;:\&quot;This file contains information about the installers used when installing the fmt (formatting library) dependency.\\n\\nKey things:\\n\\n- backtraceGraph: Contains information about the CMake files and lines that led to the install command being executed. This allows tracing the install back to the original CMake code.\\n\\n- installers: The main section, contains details of each file/target that was installed:\\n\\n  - target installer: Installs the fmt library file (libfmtd.a) to the lib directory\\n\\n  - file installer: Installs header files to the include/fmt directory\\n\\n  - file installer: Installs CMake config files to lib/cmake/fmt\\n\\n  - export installer: Exports target information to a CMake file for use by dependent projects\\n\\n  - file installer: Installs pkg-config file to lib/pkgconfig\\n\\nSo in summary, this file documents what files were installed where during the fmt install process. The key functions are to provide details of each installer used (file, target, export etc), and allow tracing the install back to the original CMake code via the backtraceGraph.\&quot;,\&quot;/cmake-build-debug/.cmake/api/v1/reply/target-fmt-Debug-6ef11bf264848d696b2b.json\&quot;:\&quot;This file contains information about a CMake target called \\\&quot;fmt\\\&quot; that was built as part of the CMake build process.\\n\\nSome key things it contains:\\n\\n- Artifacts - The path to the static library file that was built for this target (_deps/fmt-build/libfmtd.a)\\n\\n- Backtrace - Information about where in the CMake files this target was defined\\n\\n- Compile groups - Details about how source files were compiled, including includes, language, etc. \\n\\n- Install information - Where this target will be installed to on the system\\n\\n- Name, nameOnDisk - The target and library file names\\n\\n- Paths - Paths to the build and source directories\\n\\n- Source groups - How source files are organized into groups\\n\\n- Sources - The individual source files that make up this target\\n\\nSo in summary, it contains metadata about the build configuration and results for the \\\&quot;fmt\\\&quot; static library target. This allows CMake to track how it was configured and built.\\n\\nKey functions would include things like:\\n\\n- add_library() - Used to define the library target \\n- target_include_directories() - Configure include paths\\n- target_sources() - Specify source files\\n- install() - Configure installation of target\\n\\nSo it captures the configuration and outputs of the main CMake functions used to build this library target.\&quot;,\&quot;/table/Table.h\&quot;:\&quot;This file defines a Table class that represents a database table.\\n\\nKey functions:\\n\\n- createTable - Creates a new table with the given column names and types\\n- insert - Inserts a new row of data into the table \\n- load - Loads the table data from a file\\n- save - Saves the table data to a file\\n- display - Displays the contents of the table\\n- update - Updates rows in the table \\n- deleteRow - Deletes a row from the table\\n- deleteTable - Deletes the entire table\\n- createRelation - Creates relationships/joins between tables\\n\\nIt stores the table data as a vector of TableRow objects and a map of column names to data types. It also defines some enums for SQL commands and clauses. The main purpose is to model the structure and functionality of a database table in code.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/doc/build.py\&quot;:\&quot;This file is used to build the documentation for the fmt library.\\n\\nKey functions:\\n\\n- create_build_env(): Creates a virtualenv and installs Sphinx, Breathe and other dependencies needed for building the docs.\\n\\n- build_docs():\\n  - Runs Doxygen to generate XML documentation from header files\\n  - Runs Sphinx to build HTML docs from the XML and reStructuredText sources\\n  - Compiles the Less stylesheet to CSS\\n\\n- Pip class: Used to install packages into the virtualenv\\n\\nSo in summary, it:\\n\\n1. Sets up a virtualenv \\n2. Runs Doxygen to extract docs from headers\\n3. Runs Sphinx to build HTML from Doxygen XML and RST sources\\n4. Compiles the stylesheet\\n\\nThe main entry point is build_docs(), which handles running Doxygen, Sphinx and Less compilation to generate the final HTML documentation. create_build_env() sets up the required tools and dependencies.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/doc/index.rst\&quot;:\&quot;This file is the index or overview page for the documentation of the fmt formatting library.\\n\\nSome key things it does:\\n\\n- Provides a high-level overview and description of what the fmt library is and its main features.\\n\\n- Describes the main format API and how to use fmt::format, fmt::print, positional arguments, named arguments, etc. \\n\\n- Covers important aspects like safety, compile-time checks, portability, ease of use.\\n\\n- Links to other documentation pages that provide more details on syntax, API reference, contents, etc. \\n\\n- Includes code samples to demonstrate usage of the format API.\\n\\n- Embedded some styling like panels, buttons to make it readable as HTML documentation.\\n\\nKey functions/topics it introduces:\\n\\n- fmt::format - Format arguments into a string\\n- fmt::print - Format and print to a stream \\n- Positional arguments\\n- Named arguments \\n- Safety features like exceptions, compile-time checks\\n- Compact binary code generation\\n- Portability across platforms and compilers\\n- Small and self-contained library\\n\\nSo in summary, it provides a high-level overview of the fmt library capabilities as the main index/landing page for its documentation.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/support/bazel/README.md\&quot;:\&quot;This file provides documentation on how to set up and use the fmt (formatting) library with Bazel, Google\\u0027s build and test tool.\\n\\nKey functions:\\n\\n- Explains how to \\\&quot;bazelize\\\&quot; the fmt repository by copying over certain files from the fmt/support/bazel folder. This allows fmt to be used as a dependency in Bazel projects.\\n\\n- Provides a minimal example Bazel project structure and code that uses fmt as a dependency. \\n\\n- Explains how to define the fmt repository in the WORKSPACE file using git_repository. This fetches the fmt repo from GitHub. \\n\\n- Shows how to use patch_cmds to move certain files from the fmt repo to its root, bazelizing it. \\n\\n- Demonstrates defining a cc_binary target in the BUILD file that builds a demo program using fmt as a dependency.\\n\\n- Mentions Bzlmod as another way to use fmt with Bazel via the Bazel Central Registry module.\\n\\nSo in summary, it provides instructions and an example for setting up and consuming the fmt library from Bazel-based C++ projects by bazelizing the fmt repo and declaring it as an external dependency.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/support/manage.py\&quot;:\&quot;This Python file is used to manage releases and the documentation site for the fmt formatting library.\\n\\nThe key things it does:\\n\\n- Handles updating the Git repositories for fmt and the documentation site.\\n\\n- Updates the documentation for different fmt versions by checking out tags/branches, copying over theme files, building the docs. \\n\\n- Updates version numbers and the changelog when doing a release.\\n\\n- Uploads the release artifacts (docs, packages) to GitHub.\\n\\nKey functions:\\n\\n- release(args) - Handles the full release process from updating versions to uploading.\\n\\n- update_site(env) - Updates the documentation site by building docs for each version.\\n\\n- create_build_env() - Sets up the virtualenv and repositories for building. \\n\\n- Git class - Wraps Git commands to manage checking out tags/branches.\\n\\n- rewrite() context manager - Rewrites files in-place for fixes during doc generation.\\n\\nSo in summary, it automates the tasks of preparing a fmt release, building and publishing the documentation for multiple versions to the site.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/doc/_templates/layout.html\&quot;:\&quot;This file is a custom layout template for Sphinx documentation generated with the fmt formatting library.\\n\\nKey functions:\\n\\n- Extends the base Sphinx layout template \\n- Adds extra metadata like description, keywords, author\\n- Includes Google Analytics tracking script\\n- Defines a search form macro\\n- Defines the page header with navigation menu\\n- Conditionally displays download buttons on index page  \\n- Disables related links sidebar\\n- Defines page content container\\n- Includes Bootstrap JS at bottom for enhanced styling\\n\\nIn summary, it:\\n\\n- Customizes the overall page layout and design\\n- Adds analytics tracking\\n- Renders the navigation menu\\n- Handles downloads/versions on index\\n- Defines where content is displayed\\n- Includes necessary CSS/JS assets\\n\\nSo in one template it centralizes all the custom layout, styling, navigation and functionality for the fmt documentation site generated with Sphinx.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/test/fuzzing/fuzzer-common.h\&quot;:\&quot;This file contains common definitions and utilities used for fuzz testing the fmt formatting library.\\n\\nKey things it does:\\n\\n- Defines macros to configure fuzz testing behavior, like whether to format to a string or buffer, and whether to use separate allocation.\\n\\n- Defines a fixed size (16 bytes) that data will be treated as to allow cross-pollination between different types when mutating data. \\n\\n- Provides type casting utilities like as_chars() and as_bytes() to cast data to character/byte pointers.\\n\\n- assign_from_buf() utility to copy bytes from data into a constructed object of a given type.\\n\\n- data_to_string struct that handles formatting data to a string or buffer based on configuration, and exposes the result as a string_view.\\n\\nKey functions:\\n\\n- as_chars()/as_bytes() - Type casting utilities\\n- assign_from_buf() - Construct object from byte data \\n- data_to_string - Handles formatting data to string/buffer and exposing result\\n\\nSo in summary, it provides common code and utilities to help with fuzz testing formatting of different data types using fmt.\&quot;,\&quot;/cmake-build-debug/CMakeFiles/CMakeConfigureLog.yaml\&quot;:\&quot;This file is a CMake configure log file that records information about the CMake configuration process. Some key things it does:\\n\\n- Records system information like the operating system, compiler, etc. This helps identify the build environment.\\n\\n- Runs compiler identification tests to determine the C and CXX compiler IDs. This helps CMake select the right compiler-specific settings. \\n\\n- Runs compiler ABI detection tests to determine things like the compiler ABI, implicit include directories, libraries, etc. This is needed for cross-compiling.\\n\\n- Logs messages from various CMake modules as they run, like determining the compiler, compiler ID, compiler ABI, etc. This provides debugging information.\\n\\n- Records the results of \\\&quot;try compile\\\&quot; tests run by CMake to check compiler features. This includes things like compile/link commands and output.\\n\\nKey functions/sections:\\n\\n- System identification - Records OS, architecture etc. \\n- Compiler identification - Determines compiler vendor/version\\n- Compiler ABI detection - Determines ABI, includes, libraries\\n- Implicit link information parsing - Parses linker output \\n- Message logging - Records status messages\\n- Try compile results - Records feature check compilation results\\n\\nSo in summary, it logs detailed information about the CMake configuration process to identify the build environment and help with debugging. This file acts as a record of what CMake learned about the compiler.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/support/printable.py\&quot;:\&quot;This file is used to generate code for determining if a Unicode codepoint is printable in Rust.\\n\\nKey things it does:\\n\\n- Parses the UnicodeData.txt file to get codepoint classifications\\n- Groups codepoints into ranges of printable/non-printable codepoints \\n- Compresses the data into more efficient representations for single codepoints and ranges\\n- Prints out Rust code defining arrays and functions for efficiently checking if a codepoint is printable\\n\\nKey functions:\\n\\n- get_codepoints - Parses the Unicode data file\\n- to_ranges - Groups codepoints into contiguous ranges  \\n- compress_singletons - Compresses single codepoints \\n- compress_normal - Compresses ranges of codepoints\\n- print_singletons - Prints Rust code for single codepoint data\\n- print_normal - Prints Rust code for range data\\n- main - Drives the overall process of parsing, compressing, and code generation\\n\\nSo in summary, it analyzes Unicode data and generates optimized Rust code for checking Unicode codepoint printability.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-subbuild/CMakeFiles/CMakeConfigureLog.yaml\&quot;:\&quot;This file is the CMake configure log for the fmt subproject of a CMake project.\\n\\nSome key things about this file:\\n\\n- It logs messages and events from the CMake configuration process.\\n\\n- The first event logged is a \\\&quot;message\\\&quot; event, indicating that CMake determined the system is Windows 10 AMD64. This provides information about the build environment.\\n\\n- The backtrace shows where this message originated from - the CMakeDetermineSystem.cmake module and the top-level CMakeLists.txt file.\\n\\n- Additional events would be logged here for other configuration steps like checking for dependencies, generating build files, etc. \\n\\n- It allows tracing what happened during the CMake configuration to debug any issues.\\n\\n- The main functions of this file are to:\\n\\n  - Log configuration messages and events\\n\\n  - Provide a record of the CMake configuration process\\n\\n  - Allow debugging configuration problems by examining the log\\n\\nSo in summary, it acts as a log file to capture output and trace the CMake configuration for the fmt subproject being built. This helps with debugging configuration issues.\&quot;}&quot;,&quot;C:/Users/golasmi1/workspace/CPLUSPLUSDB&quot;:&quot;{\&quot;/cmake-build-debug/CMakeFiles/3.27.8/CompilerIdCXX/CMakeCXXCompilerId.cpp\&quot;:\&quot;This file is used to detect information about the compiler and build environment.\\n\\nThe key things it does:\\n\\n- Defines macros to identify the compiler (COMPILER_ID) and extract the major/minor/patch version numbers. This is done by checking for predefined macros specific to each compiler.\\n\\n- Defines macros for the platform (PLATFORM_ID) and architecture (ARCHITECTURE_ID)\\n\\n- Constructs string literals containing the compiler, platform, architecture and version information \\n\\n- Defines macros for the default C++ language standard and extensions\\n\\n- The main() function simply returns the number of string literals it constructed, to signal the level of information available\\n\\nKey functions/macros:\\n\\n- COMPILER_ID - Identifies the compiler \\n- COMPILER_VERSION_MAJOR/MINOR/PATCH - Extracts version numbers\\n- PLATFORM_ID - Identifies the platform\\n- ARCHITECTURE_ID - Identifies the CPU architecture  \\n- info_compiler, info_platform, etc - String literals with info\\n- CXX_STD - Default C++ standard\\n- main() - Returns count of constructed strings\\n\\nSo in summary, it detects various properties of the build environment and compiler to provide standardized information that can be queried by the build system or other tools.\&quot;,\&quot;/cmake-build-debug/.cmake/api/v1/reply/directory-.-Debug-d0094a50bb2071803777.json\&quot;:\&quot;This JSON file contains metadata about a CMake build directory.\\n\\nKey things it provides:\\n\\n- paths - Contains the paths to the build and source directories. This allows tools to locate where the build is taking place and the original source code.\\n\\n- backtraceGraph - Empty objects for commands, files, and nodes. This provides a place to store debugging information about the CMake execution backtrace/graph, but is empty here since debugging is not enabled. \\n\\n- installers - Empty array. This would contain information about custom install rules and targets if any were defined in the CMake code.\\n\\nSo in summary, its main functions are:\\n\\n- Provide location of build and source directories \\n- Reserve space for capturing CMake execution backtrace/graph (if debugging enabled)\\n- Reserve space for describing custom install rules (if defined)\\n\\nIt acts as a central metadata file in the build directory that tools can read to understand the context and configuration of the CMake build being performed.\&quot;,\&quot;/table/table.cpp\&quot;:\&quot;This file defines the Table class that represents a database table.\\n\\nThe key functions are:\\n\\n- Table constructor - Initializes the table name, columns, column types, etc.\\n\\n- insert() - Inserts a new row into the table.\\n\\n- display() - Prints out the contents of the table. \\n\\n- addColumn() - Adds a new column to the table.\\n\\n- update() - Updates an existing row based on conditions. \\n\\n- convertAndAssignValue() - Helper function to convert values to the correct data type.\\n\\n- save() - Saves the table to a file.\\n\\n- createRelation() - Placeholder for creating relationships between tables. \\n\\n- deleteRow() - Placeholder for deleting a row.\\n\\n- deleteTable() - Placeholder for deleting the entire table.\\n\\n- getPrimaryKey() - Gets the primary key of the table.\\n\\n- getName() - Gets the name of the table. \\n\\n- getColumns() - Gets the column definitions as a map.\\n\\nSo in summary, it defines the core functionality for representing and manipulating a database table in memory and saving/loading it to file.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/doc/conf.py\&quot;:\&quot;This file is the configuration file for building the documentation for the fmt library using Sphinx.\\n\\nKey functions:\\n\\n- Sets up Sphinx extensions like breathe for linking to Doxygen documentation.\\n\\n- Configures output formats like HTML, LaTeX, manual pages, etc. \\n\\n- Sets metadata like project name, copyright, author, etc. \\n\\n- Configures paths for templates, static files, and Doxygen output.\\n\\n- Configures Sphinx themes and templates for HTML output. \\n\\n- Groups documents into LaTeX/manual page/texinfo files for non-HTML output formats.\\n\\n- Runs Doxygen to generate API docs from headers on ReadTheDocs.\\n\\nIn summary, it configures Sphinx to:\\n\\n- Parse and render the documentation source files \\n- Link to generated API docs\\n- Produce different output formats like HTML, PDF, etc.\\n- Set metadata and templates for the build\\n\\nSo it controls how the documentation is built and formatted for different targets.\&quot;,\&quot;/utils/mapper.h\&quot;:\&quot;This file contains mapping utilities for converting between database column types and C++ types.\\n\\nKey functions:\\n\\n- mapColumnType: Maps a string representation of a database column type (e.g. \\\&quot;varchar\\\&quot;) to a DataType enum value.\\n\\n- DataTypeToStringValue: A visitor that converts a DataType variant to a string representation of its value. Used to convert database values to strings. \\n\\n- DataTypeToStringType: A visitor that converts a DataType variant to a string representation of its type (e.g. \\\&quot;STRING\\\&quot;). Used to get the type name as a string.\\n\\nThe main purpose of this file is to provide utilities for:\\n\\n1. Mapping database column types to C++ types \\n2. Converting between C++ types and string representations for values and types\\n\\nThis allows interacting with database values as C++ variants while still being able to convert them to strings for storage, display, etc. The visitors leverage std::visit to operate on the variant types.\&quot;,\&quot;/utils/printer.cpp\&quot;:\&quot;This file contains a Printer class that provides functions for printing formatted output.\\n\\nKey functions:\\n\\n- printHorizontalLine(unsigned long long size) - Prints a horizontal line of the given size by repeating the character \\u0027-\\u0027 that many times. It uses the fmt library for formatted printing.\\n\\nThis file:\\n\\n- Defines a Printer class for printing formatted output\\n- Includes the fmt library for formatted printing \\n- Contains a printHorizontalLine() method that prints a horizontal line of a given length by repeating characters\\n- Uses fmt for formatted printing of the line and newline character\\n\\nSo in summary, it provides a Printer class with a printHorizontalLine() utility function to print horizontal lines of a specified length, using the fmt library for formatted output. This allows neatly formatting output with lines for separation/formatting purposes.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/.github/pull_request_template.md\&quot;:\&quot;This file is a pull request template for the fmt (formatting library) project on GitHub. \\n\\nSome key functions/purposes of this file:\\n\\n- Provides guidance to potential contributors on submitting pull requests by linking to the project\\u0027s contribution guidelines. This helps ensure pull requests follow the project\\u0027s standards and processes.\\n\\n- Notifies contributors that by submitting a pull request they are agreeing to license their code under the project\\u0027s license terms. This helps maintain a consistent license for all code in the project. \\n\\n- Acts as a template that pull request authors can use to structure their pull request descriptions. Commonly it will have sections for things like problem description, proposed solution, testing done, etc. This helps pull requests be clear and consistent.\\n\\n- Serves as a reminder to discuss proposed changes with maintainers before submitting the pull request. Early discussion can avoid wasted effort on changes that may not be accepted. \\n\\nSo in summary, it provides guidance for contributors, obtains agreement to licensing terms, and structures pull request content - all helping the project review and accept contributions in a clear and compliant way. The template helps streamline the contribution process.\&quot;,\&quot;/cmake-build-debug/.cmake/api/v1/reply/toolchains-v1-b15c73871462cb939849.json\&quot;:\&quot;This file contains toolchain information returned by CMake in response to a request for toolchains.\\n\\nKey things:\\n\\n- It is a JSON file that defines the \\\&quot;toolchains\\\&quot; for a particular CMake build.\\n\\n- The \\\&quot;toolchains\\\&quot; array contains entries for each supported toolchain (compiler, linker etc). \\n\\n- Each toolchain entry specifies:\\n\\n  - The compiler/tool ID and version\\n\\n  - Implicit include paths, link paths and libraries\\n\\n  - The path to the compiler/tool executable\\n\\n  - The language it supports \\n\\n  - File extensions of source files it can handle\\n\\n- This provides CMake with all the information it needs to determine which toolchain to use for a given source file and how to invoke the compiler/linker.\\n\\n- The main functions of this file are:\\n\\n  - Define the available toolchains for a CMake build\\n\\n  - Provide paths and settings for each toolchain compiler/tool\\n\\n  - Allow CMake to map source files to the correct toolchain based on file extension\\n\\nSo in summary, it defines and describes the available toolchains/compilers that CMake can use for a particular build.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-build/CMakeFiles/fmt.dir/compiler_depend.ts\&quot;:\&quot;This file is a timestamp file generated by CMake for managing compiler-generated dependencies for the fmt library.\\n\\nSome key things about this file:\\n\\n- It is located in the _deps/fmt-build/CMakeFiles/fmt.dir directory, which indicates it is related to building the fmt target.\\n\\n- The filename compiler_depend.ts indicates it tracks compiler-generated dependencies. The .ts extension stands for \\\&quot;timestamp\\\&quot;.\\n\\n- CMake uses timestamp files like this to track when source files are modified, so it knows when it needs to re-run the compiler to rebuild dependent targets.\\n\\n- The main function of this file is to store the last modified time of source files that the fmt target depends on. This allows CMake to determine if dependencies are out of date.\\n\\n- When any source files are modified, this file will be updated to reflect the new timestamps. \\n\\n- CMake checks this file on subsequent builds to see if any dependencies timestamps have changed since the last build. If so, it will recompile targets as needed.\\n\\n- This helps CMake avoid unnecessary recompiles when dependencies haven\\u0027t actually changed.\\n\\nSo in summary, the key function is to track timestamps of dependent source files to help CMake efficiently manage recompiling targets only when dependencies are truly out of date.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/printf.h\&quot;:\&quot;This file defines functionality for formatted printing (printf-style formatting) in the fmt library.\\n\\nKey things it does:\\n\\n- Defines basic_printf_context and related types for handling printf arguments and formatting context.\\n\\n- Defines printf_formatter class template to handle formatting different argument types. \\n\\n- Defines parsing functions like parse_header() to parse format strings.\\n\\n- Defines printf_arg_formatter class to format arguments according to printf specs. \\n\\n- Defines vprintf() function to format and print with a printf-style format string and arguments.\\n\\nKey functions:\\n\\n- make_printf_args() - Construct format argument store from variadic args\\n- sprintf() - Format and return string \\n- fprintf() - Print formatted string to file\\n- printf() - Print formatted string to stdout\\n- vprintf() - Core formatting function that parses format string and prints\\n- parse_header() - Parse format string for argument index, flags, width\\n- printf_arg_formatter - Formats arguments according to specs\\n\\nSo in summary, it provides printf-style formatting functionality for the fmt library, including parsing format strings, handling arguments, and printing formatted output.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/std.h\&quot;:\&quot;This file (fmt/std.h) provides formatting support for standard library types in the fmt library.\\n\\nSome key things it does:\\n\\n- Defines formatters (templates specializing formatter) for common standard library types like std::string, std::vector, std::exception, etc. to allow formatting them with fmt.\\n\\n- Checks for availability of newer C++ standard library features like std::optional, std::variant, std::filesystem and conditionally includes their headers and defines formatters if available.\\n\\n- Defines utility functions and type traits used by the formatters, like checking if a type is formattable, writing escaped strings, handling dynamic width specs, etc. \\n\\n- Provides formatters for atomic types by delegating to the underlying non-atomic formatters.\\n\\n- Handles formatting of reference-like types like std::vector\\u003cbool\\u003e::reference and std::bitset references.\\n\\n- For std::exception subclasses, optionally formats the type name if specified in the format string.\\n\\nKey functions:\\n\\n- formatter templates - define the parsing and formatting logic for types\\n- is_formattable - trait to check if a type can be formatted  \\n- write_escaped_string - write a string with escapes\\n- get_path_string - get path string from std::filesystem::path\\n- write_variant_alternative - write a std::variant alternative\\n\\nSo in summary, it adds rich formatting support for common standard library types to the fmt library.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/support/rtd/theme/layout.html\&quot;:\&quot;This HTML file is used to redirect visitors from the Read the Docs documentation theme to the main fmt documentation site at fmt.dev/latest/.\\n\\nKey functions:\\n\\n- Extends the basic/layout.html template which provides the base layout and styling for RTD themes.\\n\\n- Adds a meta refresh tag that automatically refreshes the page to redirect to fmt.dev after 1 second. \\n\\n- Includes a JavaScript redirect that immediately redirects the page location to fmt.dev. \\n\\n- Sets the page title to \\\&quot;Page Redirection\\\&quot;.\\n\\n- The document block displays a fallback message with a link to fmt.dev in case the automatic redirects don\\u0027t work.\\n\\n- It overrides the footer block to be empty, removing any footer content.\\n\\nSo in summary, its purpose is to redirect visitors from the default RTD theme documentation to the main fmt site, using both HTTP refresh and JavaScript methods to perform the redirection.\&quot;,\&quot;/table/table.h\&quot;:\&quot;This file defines a Table class that represents a database table.\\n\\nKey functions:\\n\\n- Table constructor - Initializes a table with a name, column names and types.\\n\\n- display() - Prints out the contents of the table. \\n\\n- insert() - Inserts a new row into the table.\\n\\n- addColumn() - Adds a new column to the table. \\n\\n- convertAndAssignValue() - Converts a string value to the correct data type for a column.\\n\\n- createRelation() - Likely used to define foreign key relationships.\\n\\n- update() - Updates an existing row matching conditions. \\n\\n- deleteRow() - Deletes a row.\\n\\n- deleteTable() - Deletes the entire table. \\n\\n- save() - Saves the table to a file.\\n\\nIt also defines getter functions to access the table name, columns, and primary key.\\n\\nThe Command and Clause enums are likely used to define SQL commands and clauses that can be used with the table.\\n\\nSo in summary, it provides an object oriented representation of a database table with functions for common CRUD and schema operations.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/test/gtest/gtest/gtest.h\&quot;:\&quot;This file contains internal definitions and utilities used by Google Test, the C++ testing framework. Some key things it does:\\n\\n- Defines types and classes used internally by Google Test, like Message, TestInfo, TestPartResult, etc. These are not meant to be used directly by user code.\\n\\n- Defines macros and functions for registering tests and test suites, like TEST, TEST_F, TYPED_TEST_CASE, etc. These are the main entry points for writing tests with Google Test.\\n\\n- Defines utilities for comparing floating point numbers, formatting strings, parsing command line flags, etc. These are used internally by Google Test but could also be useful for user code.\\n\\n- Defines type traits and metafunctions for working with types, like GetTypeName(), TemplateSel, etc. These are used for features like typed and type-parameterized tests. \\n\\n- Defines exception classes for test failures, like GoogleTestFailureException.\\n\\n- Defines the Test and TestFixture base classes that user test fixtures are expected to inherit from.\\n\\n- Defines the internal implementation classes and data structures used by Google Test, like UnitTestImpl, TestInfoImpl, etc. These are not meant to be used directly by user code.\\n\\nSo in summary, it provides the core types, macros, utilities and implementation needed to write and run tests with Google Test. Key functions include registration macros like TEST, TEST_F, type traits, comparison utilities and the Test base classes.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/README.md\&quot;:\&quot;This README.md file is providing documentation and information about the fmt formatting library. Some key things it covers:\\n\\n- Description of what fmt is and its main features\\n- Examples of how to use fmt\\n- Benchmark results comparing fmt\\u0027s performance to other libraries\\n- Instructions on migrating code to use fmt\\n- Motivation for why fmt was created\\n- List of notable projects that use fmt\\n- Instructions for building and running tests\\n- Information about licensing and maintaining the project\\n\\nSome key sections/functions:\\n\\n- Features - Lists the main capabilities of fmt\\n- Examples - Shows code samples of common fmt usage patterns \\n- Benchmarks - Performance comparison data against other libraries\\n- Migrating code - Guidance on converting existing code to use fmt\\n- Motivation - Explains the limitations fmt aims to address\\n- Projects using fmt - Highlights popular software that integrates it\\n- Building/tests - Instructions to compile and validate the library\\n- License/documentation license - Details on legal terms for usage\\n- Maintainers - Credits the people responsible for the project\\n\\nIn summary, this README provides an overview of what fmt is, how to get started with it, performance details, legal aspects, and points of contact - essentially serving as the front page and introduction to using and contributing to the fmt formatting library.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-subbuild/CMakeFiles/fmt-populate.dir/Labels.json\&quot;:\&quot;This file is a Labels.json file that is used by CMake to track build dependencies for the fmt subproject.\\n\\nSome key things it does:\\n\\n- Lists the source files that are involved in building the fmt-populate target. This includes CMake files, rules files, stamp files etc. \\n\\n- Defines the \\\&quot;target\\\&quot; which is the fmt-populate target. \\n\\n- Associates the target name \\\&quot;fmt-populate\\\&quot; with a list of labels [\\\&quot;fmt-populate\\\&quot;]. \\n\\nThis allows CMake to:\\n\\n- Determine the files that need to be rebuilt if the fmt-populate target is rebuilt. It will look for changes in any of the source files listed.\\n\\n- Uniquely identify the fmt-populate build target. \\n\\n- Track dependencies - other targets can depend on \\\&quot;fmt-populate\\\&quot; via its labels.\\n\\nSo in summary, the key functions are:\\n\\n- Define the source files involved in building a target \\n- Identify the target uniquely via its name and labels\\n- Allow CMake to manage dependencies and rebuilds for the target\\n\\nIt\\u0027s part of CMake\\u0027s build system metadata to integrate building the fmt subproject.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/compile.h\&quot;:\&quot;This file defines functionality for compile-time format string compilation in the fmt formatting library.\\n\\nSome key things it does:\\n\\n- Defines the FMT_COMPILE macro to mark format strings that should be compiled at compile-time.\\n\\n- Defines data structures like compiled_string and is_compiled_format to represent compiled format strings.\\n\\n- Implements compile-time parsing and compilation of format strings into efficient compiled representations using constexpr functions and templates.\\n\\n- Defines node types like text, code_unit, field, spec_field that represent elements of a compiled format string. \\n\\n- Provides compile() to compile a format string at compile-time into a compiled representation.\\n\\n- Defines format() and format_to() functions that can format at compile-time using a compiled representation, avoiding runtime parsing.\\n\\n- Supports features like automatic/manual argument indexing, named arguments, format specifications in fields.\\n\\n- Handles errors and exceptions at compile-time if possible during parsing.\\n\\nKey functions:\\n\\n- compile() - compile format string to representation\\n- format(), format_to() - format using compiled representation\\n- parse_replacement_field_then_tail() - parse field and remaining string\\n- compile_format_string() - recursively parse/compile format string\\n- get_type, get_arg_index_by_name - get argument types\\n\\nSo in summary, it enables efficient compile-time formatting using compile-time parsed format strings.\&quot;,\&quot;/cmake-build-debug/CMakeFiles/2324Z_19_s26525_FK.dir/compiler_depend.ts\&quot;:\&quot;This file is a timestamp file generated by CMake to manage compiler-generated dependencies for the 2324Z_19_s26525_FK CMake target.\\n\\nSome key things about this file:\\n\\n- It is located in the CMake build directory (cmake-build-debug/CMakeFiles/) which is where CMake stores its internal build information.\\n\\n- The filename includes the target name (2324Z_19_s26525_FK) so it is uniquely associated with that target.\\n\\n- It has a .ts extension indicating it stores timestamp information.\\n\\n- Its contents are just a comment stating it is CMake-generated and should not be edited directly.\\n\\nThe main purpose and functions of this file are:\\n\\n- To track the timestamps of files that the 2324Z_19_s26525_FK target depends on via compiler-generated dependencies. \\n\\n- CMake uses the timestamps to determine if dependencies are out of date and a re-build is needed when those files change.\\n\\n- Reading and writing timestamps allows CMake to intelligently re-build only what is necessary rather than a full clean each time.\\n\\n- It is managed by CMake in the background and generally not edited by users during the normal build process.\\n\\nSo in summary, it provides dependency timestamp tracking to optimize re-builds for that specific CMake target.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/test/test-assert.h\&quot;:\&quot;This file contains test assertions for the formatting library (fmt).\\n\\nKey functions:\\n\\n- FMT_ASSERT: A macro that checks a condition and throws an assertion_failure exception if it fails, with the given message.\\n\\n- throw_assertion_failure: A function called by FMT_ASSERT to actually throw the exception. This avoids GCC warnings about throwing from a destructor.\\n\\n- assertion_failure: A class that derives from std::logic_error and is thrown on assertion failures. \\n\\n- EXPECT_ASSERT: A macro that expects an assertion failure from the given statement, matching the expected message. This is used in tests to verify assertions fail as expected.\\n\\nSo in summary, it provides test-friendly replacements for assertions that throw exceptions on failure instead of terminating, and macros to check assertions fail as expected in tests. This allows testing failure conditions and error cases in the formatting library.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/test/gtest/gtest/gtest-spi.h\&quot;:\&quot;This file contains utilities for testing Google Test itself and code that uses Google Test.\\n\\nKey things it provides:\\n\\n- ScopedFakeTestPartResultReporter class - Used to mock out Google Test\\u0027s failure reporting so failures can be intercepted and tested.\\n\\n- EXPECT_FATAL_FAILURE and EXPECT_FATAL_FAILURE_ON_ALL_THREADS macros - Verify a statement causes a fatal failure with a given substring.\\n\\n- EXPECT_NONFATAL_FAILURE and EXPECT_NONFATAL_FAILURE_ON_ALL_THREADS macros - Verify a statement causes a non-fatal failure with a given substring. \\n\\n- SingleFailureChecker class - Used by the above macros to verify only one failure occurred with the expected type and substring.\\n\\nSo in summary, it provides mock classes and macros to help test code that uses Google Test by intercepting and verifying failures are reported as expected. This allows testing Google Test itself and frameworks/code built on top of Google Test.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-subbuild/CMakeFiles/fmt-populate.dir/compiler_depend.ts\&quot;:\&quot;This file is a timestamp file generated by CMake to track dependencies for custom commands related to the fmt-populate target.\\n\\nSome key things about this file:\\n\\n- It is generated by CMake and should not be edited manually. CMake will overwrite it if changes are made to the CMake configuration.\\n\\n- It tracks the timestamp of when the custom command associated with the fmt-populate target was last run.\\n\\n- CMake uses the timestamps in these files to determine if custom commands need to be re-run when sources/dependencies change.\\n\\n- If any source files or dependencies of the custom command are newer than the timestamp in this file, CMake will re-run the custom command.\\n\\n- No actual functions are defined in this file, it just contains a timestamp. \\n\\n- The main purpose is to allow CMake to intelligently decide when custom commands associated with a target need to be re-executed based on dependency changes.\\n\\nSo in summary, it provides dependency tracking of custom commands for CMake via timestamps, but does not contain any executable code itself. CMake manages writing/reading this file to determine custom command execution.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/format.h\&quot;:\&quot;This file contains the core functionality for formatting values in fmtlib, a formatting library for C++.\\n\\nSome key things it does:\\n\\n- Defines format specifications like width, precision, alignment, etc. These are used to control how values are formatted.\\n\\n- Defines formatters for common C++ types like integers, floats, strings, etc. Formatters specify how a type is formatted according to the format specs.\\n\\n- Implements writing formatted values to output iterators like std::ostream_iterator. This is done by the write() functions.\\n\\n- Parses format strings and extracts format arguments. This is used for formatted I/O like fmt::print.\\n\\n- Defines utilities for common formatting tasks:\\n  - Grouping digits with thousands separators\\n  - Formatting pointers, enums, arrays\\n  - Joining ranges of values with a separator\\n\\n- Implements number and float formatting algorithms like decimal and exponential formatting.\\n\\n- Provides API functions for common tasks:\\n  - fmt::format() - formats and returns a string\\n  - fmt::print() - prints formatted output\\n  - fmt::format_to() - formats and writes to a character range\\n  - fmt::format_system_error() - formats system error messages\\n\\nSo in summary, this file contains the core parsing, formatting, and output functionality that makes fmtlib useful for formatted printing, string formatting, and formatting user-defined types.\&quot;,\&quot;/cmake-build-debug/.cmake/api/v1/reply/cmakeFiles-v1-f81e6ca93bc86f15133b.json\&quot;:\&quot;This file contains information about the CMake files that were used to build a CMake project.\\n\\nSome key things it provides:\\n\\n- A list of all the input CMake files that were used, including:\\n  - The main CMakeLists.txt file\\n  - Generated CMake files from the build\\n  - External CMake modules from CMake\\u0027s default module path\\n- The build and source directory paths\\n- The CMake version\\n\\nIt allows a CMake-based tool/IDE to understand the full set of CMake files and modules that were involved in the build. This allows it to:\\n\\n- Reproduce/re-generate the same build configuration \\n- Provide auto-completion and documentation for CMake commands/variables based on the modules\\n- Detect changes to CMake files and re-run configuration as needed\\n- Understand include dependencies between CMake files\\n\\nSo in summary, the key functions of this file are:\\n\\n- Providing a complete inventory of CMake inputs \\n- Specifying build/source locations\\n- Specifying the CMake version\\n- Enabling IDE features like auto-configuration, auto-completion, etc. based on the CMake files.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/format-inl.h\&quot;:\&quot;This file contains the implementation details for the formatting library fmt. Some key things it does:\\n\\n- Defines utility functions used throughout the library like is_printable(), to_decimal(), etc. These help with tasks like converting values to decimal format, checking if a codepoint is printable, etc.\\n\\n- Defines the formatter class template and specializations for common types like bigints. This allows custom formatting of user-defined types.\\n\\n- Implements vformat() and related functions for formatting arguments lists. This is the core formatting functionality.\\n\\n- Contains support for i18n features like number formatting based on locale via locale_ref. \\n\\n- Defines classes like memory_buffer for efficiently building up formatted output.\\n\\n- Provides system error reporting functions like format_system_error().\\n\\nSome key functions include:\\n\\n- vformat() - formats arguments list into a string\\n- to_decimal() - converts floating point values to decimal representation \\n- is_printable() - checks if a codepoint is printable\\n- locale_ref - handles locale-specific formatting\\n- memory_buffer - efficient output buffering\\n- format_system_error() - formats system errors\\n\\nSo in summary, this file contains the core implementation and utilities needed to format values to strings as defined by format specs. It handles number formatting, error reporting, localization and efficient output handling.\&quot;,\&quot;/table/datatype.h\&quot;:\&quot;This file defines a data type called DataType that allows a variable to hold values of different types using std::variant.\\n\\nKey things:\\n\\n- std::variant allows a variable to hold one of a set of predefined types. Here it can hold a std::string, int, float, or bool.\\n\\n- DataType is defined as an alias for std::variant\\u003cstd::string, int, float, bool\\u003e. This makes it easier to use than writing out the full std::variant type name.\\n\\n- No functions are defined, this is just a type definition header file. It allows other code to include this header and use DataType as a variable that can hold one of those base types.\\n\\n- Some key things std::variant provides are get\\u003cT\\u003e() to retrieve the value as a specific type if known, valueless_by_exception to throw if the wrong type is accessed, and visitation to apply a function to the contained value.\\n\\nSo in summary, this file defines a DataType that can hold different base types using std::variant, allowing variables of this type to dynamically take on one of those predefined types. It provides a common way for other code to use this polymorphic data type.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/chrono.h\&quot;:\&quot;This file provides date and time formatting functionality for the fmt formatting library.\\n\\nSome key things it does:\\n\\n- Defines formatter specializations for common date/time types like std::tm, std::chrono::time_point, std::chrono::duration. These allow formatting these types using format strings.\\n\\n- Defines utility types and functions for working with dates/times:\\n  - tm_writer - writes formatted date/time components to an output iterator\\n  - chrono_formatter - handles formatting durations using format strings\\n\\n- Parses format strings for date/time formatting and dispatches to handler functions.\\n\\n- Handles locale-aware formatting of dates/times using the std::time_put facet.\\n\\n- Provides utilities for converting between different date/time representations:\\n  - Converting between std::time_t and std::tm\\n  - Extracting components from durations like hours/minutes\\n  - Formatting fractional seconds\\n\\n- Support for alternative numeric representations in different locales\\n\\n- Safe conversions between std::chrono durations to avoid overflow\\n\\nSo in summary, it provides the core functionality needed to format dates, times, and durations in a locale-aware manner for the fmt library.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/test/mock-allocator.h\&quot;:\&quot;This file defines mock allocators for testing purposes in the fmt (formatting) library.\\n\\nKey things:\\n\\n- mock_allocator is a template class that mocks an allocator for a type T. It declares MOCK_METHOD macros from Google Mock to mock the allocate and deallocate functions.\\n\\n- allocator_ref is a wrapper class that holds a reference to an allocator. It allows passing allocators around and accessing the underlying allocate/deallocate functions. \\n\\n- allocate and deallocate are declared to forward calls to the underlying allocator\\u0027s versions via std::allocator_traits.\\n\\nKey functions:\\n\\n- mock_allocator::allocate - Mocks the memory allocation function \\n- mock_allocator::deallocate - Mocks the memory deallocation function\\n- allocator_ref::allocate - Forwards allocation to underlying allocator\\n- allocator_ref::deallocate - Forwards deallocation to underlying allocator\\n\\nSo in summary, it allows mocking out allocators and passing them around to test code that uses custom allocators.\&quot;,\&quot;/utils/mapper.cpp\&quot;:\&quot;This file contains a mapper class that is used to map database column types to native data types.\\n\\nThe key functions are:\\n\\n- mapColumnType() - Takes in a column type as a string and returns the corresponding native data type. It maps:\\n  - \\\&quot;string\\\&quot;/\\\&quot;STRING\\\&quot; to std::string\\n  - \\\&quot;int\\\&quot;/\\\&quot;INT\\\&quot; to int\\n  - \\\&quot;float\\\&quot;/\\\&quot;FLOAT\\\&quot; to float \\n  - \\\&quot;bool\\\&quot;/\\\&quot;BOOL\\\&quot; to bool\\n\\nThis function allows retrieving column types from a database and mapping them to native types that can be used in the programming language, without having to write explicit type conversion code each time.\\n\\nThe mapper class abstracts away the mapping between database column types and programming language data types, making it easier to retrieve and use data from the database in a typesafe way within the code.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/ChangeLog.md\&quot;:\&quot;This file contains the changelog for the fmt formatting and output library. Some key things it documents:\\n\\n- Version history and release notes for each version of fmt. This allows users to see what changed between releases.\\n\\n- New features and functionality added in each release, such as support for new data types, additional format specifiers, performance improvements, etc. \\n\\n- Bug fixes and resolved issues for each release.\\n\\n- Documentation improvements and updates.\\n\\n- Build system and test improvements.\\n\\n- Compiler warning fixes.\\n\\nBy reviewing the changelog, a user can:\\n\\n- See an overview of the library\\u0027s development and evolution over time.\\n\\n- Find out when a particular feature or fix was introduced.\\n\\n- Check if an issue they encountered has already been resolved in a newer version. \\n\\n- Identify the minimum required version for features they need.\\n\\n- Understand any backwards incompatible changes between major versions.\\n\\nSo in summary, the key functions of this file are to:\\n\\n- Document the version history and release notes of the fmt library\\n- Communicate new features, improvements and bug fixes for each release\\n- Help users track changes and determine appropriate versions to use\\n\\nIt provides transparency into the library\\u0027s development and helps users stay up-to-date on its capabilities and status.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/doc/_templates/search.html\&quot;:\&quot;This file defines the template for the search page in Sphinx documentation.\\n\\nKey functions:\\n\\n- Inherits from the base layout template \\n- Sets the page title to \\\&quot;Search\\\&quot;\\n- Includes the JavaScript search tools script\\n- Defines a JavaScript block to load the search index\\n- Displays a header and intro text for the search functionality\\n- Renders the search form \\n- Checks if a search was performed and displays results\\n- Loops through search results and outputs the href, caption and context for each\\n- Displays a \\\&quot;no results\\\&quot; message if no matches are found\\n\\nIn summary, it provides the HTML structure and template logic to display the search form, perform searches, and output any matching results from the documentation index. The template works with the Sphinx search JavaScript to enable live searching of the documentation.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/ranges.h\&quot;:\&quot;This file defines support for formatting ranges (collections of elements) and tuples in fmt.\\n\\nKey things it does:\\n\\n- Defines is_range, is_tuple_like, is_tuple_formattable traits to determine if a type can be formatted as a range or tuple.\\n\\n- Defines range_formatter and formatter specializations for formatting ranges and tuples. This includes parsing format specifications and formatting the elements.\\n\\n- Defines utilities like range_begin, range_end, tuple_size, tuple_element to work with ranges and tuples.\\n\\n- Defines join() functions to format a tuple or initializer_list with separated elements.\\n\\n- Supports customizing the formatting of ranges/tuples like setting separators, brackets etc. \\n\\n- Handles different kinds of ranges like maps, sets, sequences specially.\\n\\nKey functions:\\n\\n- range_formatter - formats a single range element  \\n- formatter for ranges/tuples - formats the whole range/tuple\\n- join() - formats a collection with separated elements\\n- is_range, is_tuple_like, is_tuple_formattable - type traits\\n- range_begin, range_end - get range element iterators\\n- tuple_size, tuple_element - get tuple metadata\\n\\nSo in summary, it adds support for formatting collections of elements like ranges and tuples to the fmt library.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/support/compute-powers.py\&quot;:\&quot;This Python file computes and prints out the significands and exponents of powers of 10 from 10^-348 to 10^340.\\n\\nKey things it does:\\n\\n- Defines a class called fp to hold the significand (f) and exponent (e) values for each power\\n- Loops through exponents from min_exponent to max_exponent, incrementing by step\\n- For each exponent:\\n  - Computes the value of 10^exp \\n  - Rounds it to a 64-bit binary significand \\n  - Stores the significand and exponent in an fp object\\n  - Appends the fp object to a powers list\\n- Prints out the significands of each power in hex format\\n- Prints out the exponents of each power  \\n- Prints the maximum difference between consecutive exponents\\n\\nKey functions:\\n\\n- range() to generate the exponents to iterate over\\n- 10**exp to compute the power values \\n- format() to convert numbers to binary and round\\n- print() to output the results\\n- fp class to store significand/exponent pairs\\n\\nSo in summary, it efficiently computes a table of normalized floating point powers of 10 over a wide exponent range.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/color.h\&quot;:\&quot;This file defines color support for the formatting library fmt.\\n\\nKey things it does:\\n\\n- Defines enum classes for colors (color) and terminal colors (terminal_color)\\n- Defines enum class for text emphasis styles (emphasis)\\n- Defines struct rgb for storing RGB color values\\n- Defines struct color_type to represent either an RGB or terminal color\\n- Defines class text_style to represent a text formatting style with colors and emphasis\\n- Defines functions like fg(), bg() to create text styles from colors\\n- Defines functions like print(), format() to format and output colored text\\n- Defines formatting support for styled arguments with color/emphasis\\n- Defines styled() function to create styled arguments\\n\\nKey functions:\\n\\n- fg(), bg() - create text styles from foreground/background colors\\n- print(), format() - format and output colored text \\n- vformat(), vformat_to() - low-level formatting functions\\n- text_style - represents a text formatting style\\n- color_type - represents a color \\n- styled() - create styled arguments for formatting\\n- ansi_color_escape - generates ANSI escape sequences for colors\\n\\nSo in summary, it provides types and functions for defining and applying text styles with colors and emphasis via ANSI escape codes when formatting and outputting text.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/os.h\&quot;:\&quot;This file (fmt/os.h) contains OS-specific functionality for the formatting library fmt.\\n\\nSome key things it does:\\n\\n- Defines platform-specific macros like FMT_POSIX, FMT_SYSTEM, etc. to abstract differences between POSIX and Windows.\\n\\n- Defines cstring_view, a reference to a null-terminated string that can be constructed from C strings or std::strings.\\n\\n- Defines buffered_file and file classes to represent file handles/descriptors in a platform-independent way.\\n\\n  - buffered_file wraps a FILE* and provides buffered I/O.\\n\\n  - file wraps a file descriptor/handle and provides unbuffered I/O.\\n\\n- Defines ostream class for fast unbuffered output to files.\\n\\n- output_file() function to open a file for writing and return an ostream.\\n\\nKey functions:\\n\\n- buffered_file constructor to open a file\\n- file constructor to open a file  \\n- file::read(), file::write() for I/O\\n- ostream::print() to format and write to a file\\n- output_file() to conveniently open and get an ostream\\n- windows_error() to throw Windows-specific errors\\n\\nSo in summary, it provides platform-independent wrappers for files, file I/O and output streams to integrate IO functionality into the fmt library.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/.github/issue_template.md\&quot;:\&quot;This file is an issue template for the fmt (formatting library) project on GitHub. \\n\\nWhen a new issue is created in the fmt repository on GitHub, this template will be pre-populated in the issue description to provide guidance to the person submitting the issue.\\n\\nThe key purpose and functions of this file are:\\n\\n- Provide instructions to ensure the reported issue reproduces on the current master branch before submitting. This helps avoid reporting issues that may have already been fixed.\\n\\n- Suggest including a minimal code sample to reproduce the issue on Compiler Explorer if possible. Compiler Explorer allows live debugging of code across different compilers, which can help the maintainers diagnose and fix the problem.\\n\\n- Acts as a template to structure the issue report and capture relevant details like steps to reproduce, expected vs actual behavior, system configuration etc. This helps the maintainers understand and address the problem more efficiently. \\n\\n- Helps improve the quality of issues reported by guiding the submitter on what information is needed. This saves the maintainers\\u0027 time chasing for more details in the issue discussion.\\n\\nSo in summary, it provides guidelines and templates to streamline the issue reporting process for the fmt project on GitHub.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/doc/_static/bootstrap.min.js\&quot;:\&quot;This file is the main JavaScript file for Bootstrap, a popular front-end framework. Some key things it does:\\n\\n- Initializes and provides jQuery/Popper.js dependencies\\n- Defines plugins/components as classes that extend the base Plugin class (e.g. Alert, Button, etc.)\\n- Registers plugins/components with jQuery/Popper via the jQueryInterface static method\\n- Defines common utility functions like getElementFromSelector, find, etc. in the Util module\\n- Defines the base Plugin class that all plugins extend, with common methods like dispose, enable, etc.\\n- Defines individual plugin classes like Alert, Button, Modal, etc. with their unique logic and APIs\\n- Attaches plugin-specific event listeners to initialize and handle plugin behavior\\n- Exports all plugin classes to be used individually or together\\n\\nSome key functions:\\n\\n- jQueryInterface - Registers plugins with jQuery \\n- Plugin.getOrCreateInstance - Gets existing instance or creates new one\\n- Plugin.dispose - Cleans up plugin instance\\n- Util functions like find, closest, etc.\\n- Individual plugin class methods like show, hide, toggle\\n- Event handlers for plugin behavior like clicks, keypresses\\n\\nSo in summary, it provides the core framework and initializes all the individual Bootstrap plugins/components to work together seamlessly.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/test/gtest-extra.h\&quot;:\&quot;This file defines additional custom Google Test assertions for testing formatting library code.\\n\\nKey functions:\\n\\n- FMT_TEST_THROW_: Macro that tests if a statement throws the expected exception with the expected message.\\n\\n- EXPECT_THROW_MSG: Convenience macro that calls FMT_TEST_THROW_ to test for exception. \\n\\n- system_error_message: Helper function to generate the expected error message string for system_error exceptions.\\n\\n- EXPECT_SYSTEM_ERROR: Macro to test if a statement throws a system_error with the expected code and message.\\n\\n- output_redirect: Class that captures output written to a file by redirecting it to a pipe. \\n\\n- restore_and_read(): Method on output_redirect that reads the captured output from the pipe.\\n\\n- FMT_TEST_WRITE_: Macro that tests if a statement writes the expected output to a file. \\n\\n- EXPECT_WRITE: Convenience macro that calls FMT_TEST_WRITE_.\\n\\n- suppress_assert: Class that suppresses Windows assertions to avoid crashes on invalid file operations.\\n\\n- EXPECT_SYSTEM_ERROR_NOASSERT: Version of EXPECT_SYSTEM_ERROR that uses suppress_assert.\\n\\n- read(): Helper function to read from a file.\\n\\n- EXPECT_READ: Macro to test reading expected content from a file.\\n\\nSo in summary, it defines macros and helpers for testing exceptions, file I/O, and capturing output in formatting library tests.\&quot;,\&quot;/cmake-build-debug/CMakeFiles/3.27.8/CompilerIdC/CMakeCCompilerId.c\&quot;:\&quot;This file is used to detect the compiler and platform being used to compile a C program. It defines macros and strings that provide information about the compiler, platform, architecture, and language standards.\\n\\nKey functions/purposes:\\n\\n- Defines compiler identification macros like COMPILER_ID based on the compiler preprocessor definitions. This identifies compilers like GCC, Clang, MSVC, etc.\\n\\n- Defines platform identification macros like PLATFORM_ID based on common platform defines. This identifies platforms like Linux, Windows, macOS, etc. \\n\\n- Defines architecture identification macros like ARCHITECTURE_ID based on compiler/platform. Identifies x86, ARM, PowerPC, etc.  \\n\\n- Defines version macros like COMPILER_VERSION_MAJOR, COMPILER_MINOR for the compiler version.\\n\\n- Defines strings like info_compiler, info_platform, info_version that contain the identification information.\\n\\n- The main() function simply returns the number of characters in these strings, which is used by the program that runs this file to get the identification information.\\n\\nSo in summary, it provides a standardized way for a C program to detect details about the compiler, platform and target architecture being used to compile the program. This information can then be used for build scripts, configuration, etc.\&quot;,\&quot;/utils/printer.h\&quot;:\&quot;This file declares a Printer struct that contains static utility functions for printing.\\n\\nKey points:\\n\\n- printer.h is a header file that is included by other files to get access to the Printer struct definition and functions.\\n\\n- Printer is declared as a struct, indicating it contains only static functions and no data members.\\n\\n- printHorizontalLine is a static member function of Printer that takes a size parameter and prints a horizontal line of that length. \\n\\n- By declaring the function static, it does not require an instance of the Printer struct to be called - it can be called directly via Printer::printHorizontalLine().\\n\\n- This allows printHorizontalLine to be used as a simple utility function without needing to create a Printer object.\\n\\nSo in summary, this header:\\n\\n- Declares a Printer struct for organizing printing utility functions\\n- Defines a single static member function printHorizontalLine() that can print a horizontal line\\n- Allows other files to include this header and call Printer::printHorizontalLine() without an object\\n\\nIt provides a simple printing utility via a single static function defined in the Printer struct.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/ostream.h\&quot;:\&quot;This file provides support for formatting and printing to std::ostream streams like std::cout in the formatting library fmt.\\n\\nKey things it does:\\n\\n- Defines formatter classes like basic_ostream_formatter that allow formatting objects that can be streamed to ostream with operator\\u003c\\u003c.\\n\\n- Defines streamed() function that creates a view wrapping a value to be formatted via streaming. \\n\\n- Defines format_value() function that formats a value to a buffer using an ostream.\\n\\n- Defines write_buffer() to write a buffer to an ostream.\\n\\n- Defines vprint() function that formats to a buffer and writes to ostream, handling UTF-8 detection. \\n\\n- Defines print() and println() convenience functions that format and print to ostream.\\n\\nKey functions:\\n\\n- streamed() \\n- format_value()\\n- write_buffer()\\n- vprint()\\n- print()\\n- println()\\n\\nSo in summary, it provides the core functionality to format values and print the results to std::ostream streams using the formatting syntax and APIs from fmt.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/support/rtd/index.rst\&quot;:\&quot;This file is an index.rst file that is used for Read the Docs documentation generation for the fmt library.\\n\\nSome key things about this file:\\n\\n- It is located in the _deps/fmt-src/support/rtd directory, which indicates it is likely being used to configure documentation builds for the fmt dependency.\\n\\n- The contents redirect the user to the main fmt documentation website at fmt.dev, rather than trying to build/host the docs locally. This is common for libraries to link to their hosted documentation rather than rebuild it from source for each project.\\n\\n- Read the Docs uses reStructuredText (.rst) files to define the documentation structure and content. This file simply contains a redirect message with a link to the main fmt docs site. \\n\\n- No functions are defined in this file, as it is just providing a redirect. The key \\\&quot;function\\\&quot; is to redirect users viewing the documentation build for the project dependency to the canonical hosted documentation instead of building docs locally.\\n\\nSo in summary, this index.rst file is a configuration file used by Read the Docs to redirect users to the main fmt documentation website rather than attempting to build docs for the fmt dependency from the source included in this project. It provides a simple redirect without any other logic or functions.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/support/build-docs.py\&quot;:\&quot;This Python script builds and publishes the documentation for the fmt library.\\n\\nKey functions:\\n\\n- rmtree_if_exists(dir) - Recursively deletes a directory if it exists. Used to clean up before cloning/copying files.\\n\\n- build_docs() from the build module - Builds the documentation HTML files.\\n\\n- shutil.copytree() - Copies the built HTML files to the fmtlib.github.io repo. \\n\\n- git commands - Clones the fmtlib.github.io repo, commits any changes, and pushes to GitHub. Used to publish the updated docs.\\n\\n- Popen() - Runs git push in a subprocess to push commits to GitHub. Handles authentication for CI pushes.\\n\\nThe overall purpose is to:\\n\\n1. Build the documentation \\n2. Copy the built files to the GitHub Pages repo\\n3. Commit and push the changes to publish the updated docs\\n\\nIt\\u0027s designed to run automatically in CI to rebuild and publish docs on every commit.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/test/posix-mock.h\&quot;:\&quot;This file (posix-mock.h) contains mocks/stubs of various POSIX/system functions for testing purposes in the fmt library.\\n\\nThe key things it does:\\n\\n- Defines namespaces test to contain the mock functions\\n- Includes relevant system header files \\n- Defines typedefs like size_t and ssize_t for portability\\n- Mocks functions like:\\n  - open, close, read, write - for file I/O\\n  - pipe - for creating pipes\\n  - fopen, fclose - for file streams\\n  - sysconf - system configuration\\n  - GetFileSize - file size on Windows\\n- Wraps system calls in FMT_SYSTEM to use mocks instead of real functions\\n\\nThe goal is to allow testing code that uses POSIX/system functions without linking to the real implementations. This allows testing on any platform by mocking out the dependencies.\\n\\nKey functions mocked:\\n\\n- open, close, read, write \\n- pipe\\n- fopen, fclose, fileno\\n- sysconf, GetFileSize \\n- dup, dup2\\n- fdopen\\n- newlocale\\n\\nSo in summary, it mocks common POSIX/system calls to enable platform-independent unit testing of code using those APIs.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/test/gtest/gmock/gmock.h\&quot;:\&quot;This file contains definitions and implementations for Google Mock matchers.\\n\\nSome key things it does:\\n\\n- Defines macros like MATCHER, MATCHER_P, etc to allow defining custom matchers.\\n\\n- Implements common polymorphic matchers like Anything(), IsNull(), NotNull(), Ref(), etc. \\n\\n- Implements common value matchers like Eq(), Ne(), Lt(), Gt(), etc.\\n\\n- Implements string matchers like StrEq(), HasSubstr(), StartsWith(), EndsWith() etc.\\n\\n- Defines CardinalityInterface for defining cardinalities of mock function calls.\\n\\n- Defines the Matcher class template which represents a matcher.\\n\\n- Defines functions like MatcherCast(), SafeMatcherCast() to cast matchers between types. \\n\\n- Defines macros like ON_CALL, EXPECT_CALL to specify expectations on mock functions.\\n\\n- Defines classes like MatcherInterface, CardinalityInterface which custom matchers/cardinalities must implement.\\n\\n- Defines utilities like MakeMatcher(), MakePolymorphicMatcher() to create Matcher objects.\\n\\n- Defines classes like MatchResultListener for explaining match results.\\n\\nSo in summary, it provides the core matcher implementation and infrastructure needed for defining and using matchers with Google Mock.\&quot;,\&quot;/cmake-build-debug/.cmake/api/v1/reply/target-fmt-Debug-038cd6296394d3f7de66.json\&quot;:\&quot;This file contains information about a CMake target called \\\&quot;fmt\\\&quot; that was built as part of the CMake configuration.\\n\\nSome key things it contains:\\n\\n- Artifacts - The path to the static library file that was built for this target (_deps/fmt-build/libfmtd.a)\\n\\n- Backtrace - Information about where in the CMake files this target was defined\\n\\n- Compile groups - Details about how source files were compiled, including includes, language, etc. \\n\\n- ID - A unique identifier for this target\\n\\n- Install - Where the target artifacts will be installed to \\n\\n- Name - The target name (\\\&quot;fmt\\\&quot;) \\n\\n- Paths - Paths to the build and source directories\\n\\n- Source groups - Grouping of source files \\n\\n- Sources - The source files that were built as part of this target\\n\\n- Type - That it produces a STATIC_LIBRARY\\n\\nSo in summary, this file contains metadata about the \\\&quot;fmt\\\&quot; target that was built by CMake, including details about its compilation, installation, and the source files that were used to build it. This allows CMake to track dependencies and configuration of this library target.\&quot;,\&quot;/cmake-build-debug/.cmake/api/v1/reply/target-2324Z_19_s26525_FK-Debug-3343aa0757cdde254d92.json\&quot;:\&quot;This JSON file contains build information for a C++ target called \\\&quot;2324Z_19_s26525_FK\\\&quot; in CMake.\\n\\nSome key things it contains:\\n\\n- Artifacts - The executable and PDB files generated by building this target\\n- Backtrace graph - The CMake commands and files that were used to define this target\\n- Compile groups - Information about compiling the source files, like compiler flags and includes\\n- Dependencies - Any other targets this target depends on \\n- Sources - The source files that make up this target\\n- Link information - How the sources were linked together, libraries used, etc.\\n\\nSome key functions of this file:\\n\\n- Provides a machine-readable definition of the target that was built\\n- Allows tools to understand how the target was configured and built\\n- Contains metadata like source file paths, compiler options, libraries linked, etc. \\n- Defines the relationship between this target and other targets/CMake files\\n- Enables functionality like building portions of the project incrementally based on changes\\n- Acts as a record of how to rebuild the target from source\\n\\nSo in summary, it contains detailed metadata about how a C++ project target was built from its CMake definition, to enable tools and workflows that rely on understanding the build configuration and outputs.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/test/fuzzing/README.md\&quot;:\&quot;This file provides instructions for running the fuzzers that are part of the fmt library test suite locally.\\n\\nKey points:\\n\\n- It describes a helper script (build.sh) that builds the fuzzers, which has only been tested on Linux so far. \\n\\n- It provides sample CMake commands that can be used to build the fuzzers on any platform supported by Clang, not just Linux. This involves setting certain CMake options and compiler flags.\\n\\n- It explains how to execute a built fuzzer, which involves setting the UBSAN_OPTIONS environment variable and running the fuzzer binary, specifying an output directory.\\n\\nSo in summary:\\n\\n- Provides build instructions for the fuzzers\\n- Suggests using a helper script or alternative CMake/compiler commands \\n- Explains how to run a built fuzzer binary\\n\\nThe main functions are:\\n\\n- Building the fuzzers via CMake\\n- Executing a built fuzzer to fuzz a target\\n\\nSo the key purpose is to enable users to build and run the fmt fuzzers locally for testing purposes.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/core.h\&quot;:\&quot;This file defines the core functionality of the fmt formatting library. Some key things it does:\\n\\n- Defines common types like basic_string_view, format_specs, etc that are used throughout the library.\\n\\n- Defines core classes like basic_format_context, basic_format_arg, basic_format_args that represent formatting contexts, arguments, and argument lists. \\n\\n- Defines type traits like is_formattable, mapped_type_constant, etc to map C++ types to internal representation types.\\n\\n- Defines parsing functions like parse_format_specs that parse format specifiers from format strings.\\n\\n- Defines format string classes like basic_format_string that represent compile-time format strings.\\n\\n- Defines formatting functions like vformat, format, format_to, format_to_n that do the actual formatting.\\n\\n- Defines printing functions like print, println that format and write output to stdout/files.\\n\\n- Defines helper functions like make_format_args, formatted_size to construct argument lists and get output sizes.\\n\\n- Defines formatters for built-in types that handle parsing/formatting of types like int, string, etc.\\n\\nSo in summary, it provides the core types, classes, functions and formatters that implement the core formatting functionality of the fmt library.\&quot;,\&quot;/database/database.h\&quot;:\&quot;This database.h file defines a Database class that represents a database containing multiple tables.\\n\\nThe key functions it provides are:\\n\\n- getTable(const std::string\\u0026 name) - Returns a pointer to the Table object with the given name. This allows accessing a specific table by name.\\n\\n- addTable(const Table\\u0026 table) - Adds a new Table object to the database\\u0027s collection of tables. \\n\\n- loadTable(const std::string \\u0026filePath) - Loads a table from a file. Presumably this populates a new Table object and adds it to the database.\\n\\nSo in summary, this Database class provides an interface to:\\n\\n- Store and manage multiple Table objects \\n- Look up tables by name\\n- Add new tables \\n- Load tables from files into the database\\n\\nIt acts as a container and manager for the collection of tables that make up the entire database.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/args.h\&quot;:\&quot;This file defines classes and functions for handling dynamic argument lists in the fmt formatting library.\\n\\nKey things:\\n\\n- detail::dynamic_arg_list - Stores arguments dynamically as they are added. Each argument is stored in a typed node.\\n\\n- dynamic_format_arg_store - Stores formatting arguments that can be passed to formatting functions. It has a vector to store basic arguments and a dynamic_arg_list to store arguments that don\\u0027t fit in the vector.\\n\\n- push_back() functions - Add an argument to the dynamic store, copying if needed. Overloads for regular arguments, references, and named arguments.\\n\\n- clear() - Erases all elements from the store. \\n\\n- reserve() - Reserves space in the storage vectors.\\n\\nSo in summary, it provides dynamic storage and management of formatting arguments that can grow as needed, to be passed to formatting functions like vformat(). The key classes are dynamic_arg_list for dynamic storage and dynamic_format_arg_store as the public API.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/support/AndroidManifest.xml\&quot;:\&quot;This file is an Android manifest file for the fmt library.\\n\\nThe Android manifest file provides essential information about an Android application to the Android system, which needs this file to run the application.\\n\\nSome key functions and information provided by this manifest file:\\n\\n- Declares the package name for the fmt library as \\\&quot;dev.fmt\\\&quot;. This uniquely identifies the library and its components.\\n\\n- Does not declare any components (activities, services, etc.) since this is a library and not a standalone app. Libraries typically don\\u0027t need to declare components. \\n\\n- Provides no permissions, since the library itself does not need any permissions to function. Any permissions would be declared by apps using this library.\\n\\n- Sets up the basic building blocks and configuration for the library to operate as a package for Android. Allows the library code and resources to be included and accessed by other Android applications.\\n\\n- Tells the Android system the basic details it needs to be aware of the library and its location within the application package hierarchy.\\n\\nSo in summary, it identifies the library package and sets up the basic configuration for the library to be included and used by other Android applications, without declaring any specific app components or permissions of its own.\&quot;,\&quot;/utils/parser.h\&quot;:\&quot;This file declares a Parser class that contains functions for parsing SQL statements.\\n\\nKey things:\\n\\n- It\\u0027s a header file included with #pragma once to avoid multiple inclusion issues.\\n\\n- It includes the string header as it will likely be parsing and working with strings. \\n\\n- It declares a Parser class.\\n\\n- The only function declared is parseCreateTable, which is static. This suggests the Parser class contains only static utility functions rather than instance methods.\\n\\n- parseCreateTable takes no parameters and returns a string. This implies it will parse a CREATE TABLE statement from somewhere and return the parsed result as a string.\\n\\nSo in summary:\\n\\n- It declares a Parser utility class with static functions.\\n- The only function declared is parseCreateTable() which parses a CREATE TABLE statement and returns the result as a string.\\n- It provides an interface for parsing SQL statements like CREATE TABLE into a usable format like strings.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/doc/basic-bootstrap/layout.html\&quot;:\&quot;This file is the master layout template for Sphinx themes. It defines the overall structure and common elements of HTML pages generated by Sphinx.\\n\\nKey functions:\\n\\n- Defines the basic HTML document structure - doctype, html, head, body tags\\n- Includes CSS and JavaScript files \\n- Renders the sidebar if enabled\\n- Defines blocks for common page elements - header, footer, content, sidebar\\n- Renders navigation bars (relbar)\\n- Includes metadata like page title, links, scripts\\n- Defines macros for common repeated elements\\n- Renders the document content body\\n- Includes translation strings\\n- Passes Sphinx configuration variables to templates\\n\\nIn summary, it provides the skeleton and common infrastructure for Sphinx HTML output, while individual page content is defined in child templates that extend this base layout. This allows for a consistent look and feel across documentation generated by Sphinx.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/include/fmt/xchar.h\&quot;:\&quot;This file (fmt/xchar.h) provides support for wide character (wchar_t) and exotic character types in the formatting library FMT.\\n\\nSome key things it does:\\n\\n- Defines wide character string and formatting context types like wstring_view, wformat_parse_context, wformat_context, etc. analogous to the basic string/context types.\\n\\n- Provides wide character formatting functions like format(), vformat(), format_to(), etc. that work similarly to the basic string versions but for wchar_t. \\n\\n- Adds support for locale-aware formatting of wide characters.\\n\\n- Defines join() and to_string() functions that work on wide character strings. \\n\\n- Prints to files/stdout using wide character strings via vprint(), print(), println().\\n\\n- Converts values to wide strings using to_wstring().\\n\\n- Enables formatting of \\\&quot;exotic\\\&quot; character types like char16_t via templates.\\n\\nSo in summary, it extends the core FMT functionality to support formatting and I/O with wide character strings in addition to basic strings. This allows using FMT with international text and locales that use wide characters.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/CONTRIBUTING.md\&quot;:\&quot;This file contains guidelines for contributing to the fmt library.\\n\\nSome key points:\\n\\n- By submitting a pull request or patch, you are agreeing to license your contribution under the fmt license and agree to future changes to the licensing.\\n\\n- All C++ code must adhere to the Google C++ Style Guide, with some exceptions noted for allowing exceptions and using snake_case naming. \\n\\n- All documentation must adhere to the Google Developer Documentation Style Guide.\\n\\n- It provides information on the code style and formatting guidelines that contributors need to follow when submitting code changes to the fmt library. \\n\\n- It also covers licensing terms that contributors agree to by submitting code to the project.\\n\\nSo in summary, this CONTRIBUTING file outlines the contribution process and guidelines for code style, documentation style, and licensing that contributors need to follow when submitting code to the fmt library project.\&quot;,\&quot;/cmake-build-debug/.cmake/api/v1/reply/cache-v2-676b4e3a90d34015c8b2.json\&quot;:\&quot;This file contains the cache entries for a CMake project. The CMake cache is used to store configuration values that are set by the project and by CMake itself.\\n\\nSome key things about this file:\\n\\n- It contains a JSON representation of the cache entries, with each entry stored as a JSON object.\\n\\n- The entries contain metadata like the name, type, properties, and value of each cache variable. \\n\\n- Common cache variables include things like CMAKE_BUILD_TYPE, CMAKE_CXX_COMPILER, installation paths, etc. These configure build settings.\\n\\n- It also contains entries for external dependencies like FMT that were fetched by CMake. These store configuration for those dependencies.\\n\\n- The cache persists between CMake runs so configured values are remembered.\\n\\n- CMake uses the cache to store/retrieve configuration during the build process. Projects can also read/write values.\\n\\n- Developers can edit the cache manually to tweak settings like compiler flags without re-running CMake.\\n\\nSo in summary, the CMake cache file:\\n\\n- Stores all configuration values for a CMake-based project \\n- Persists between CMake runs for a build directory\\n- Is read/written by CMake and projects to configure the build\\n- Can be manually edited to tweak CMake settings\\n\\nIt acts as the central configuration store for a CMake build directory.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/test/scan.h\&quot;:\&quot;This file defines a scanning API for formatting library (fmt) as a proof of concept.\\n\\nKey things it does:\\n\\n- Defines scan_buffer and related classes like string_scan_buffer and file_scan_buffer to represent input buffers for scanning.\\n\\n- Defines scan_iterator, scan_context and related classes to represent the scanning state.\\n\\n- Defines scan_arg to represent scan arguments. \\n\\n- Defines scanners for built-in types like integers, strings etc. Also allows custom scanners.\\n\\n- Defines scan_handler to parse format strings and handle scanning.\\n\\nKey functions:\\n\\n- vscan: Main scanning function that takes a buffer, format string and arguments.\\n\\n- scan: Convenience functions to scan from a string, input range or file.\\n\\n- make_scan_args: Helper to create scan_args from variable arguments. \\n\\n- basic_scan_arg: Base class for scan arguments.\\n\\n- scan_context: Represents scanning context during parsing.\\n\\n- scan_handler: Parses format strings and handles scanning callbacks. \\n\\n- read functions: Functions to read/scan values of different types from the input.\\n\\nSo in summary, it defines the necessary classes and functions to implement scanning/format parsing from an input source based on a format string, similar to scanf.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/doc/syntax.rst\&quot;:\&quot;This file defines the format string syntax used by fmt library for formatting arguments in functions like fmt::format() and fmt::print().\\n\\nSome key things it does:\\n\\n- Defines the grammar for replacement fields (braces {}) in format strings, including argument IDs, format specs, nested replacement fields etc. \\n\\n- Describes the format specification mini-language used to define formatting options like width, alignment, precision etc for different types.\\n\\n- Lists the available format types/specifiers for different types like integers, floats, strings, chrono types etc. \\n\\n- Defines chrono and range format specifications with custom syntax.\\n\\n- Provides examples of common format string usages and comparisons to printf formatting.\\n\\nKey functions/sections:\\n\\n- format() - The main formatting function that takes a format string and arguments.\\n\\n- syntax - Defines the overall format string syntax. \\n\\n- formatspec - Describes the format spec mini language for types.  \\n\\n- chrono-specs - Format specs for chrono types like dates/times.\\n\\n- range-specs - Format specs for range types. \\n\\n- formatexamples - Example format strings and outputs.\\n\\nSo in summary, this file defines the format string syntax and specifications that are central to how formatting works with the fmt library. It\\u0027s a reference for understanding the format string language.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/doc/contents.rst\&quot;:\&quot;This file is a contents file for documentation generated using Sphinx for the fmt (formatting) library.\\n\\nKey things about this file:\\n\\n- It is a reStructuredText (.rst) file, which is the file format used by Sphinx for documentation markup.\\n\\n- The \\\&quot;contents\\\&quot; in the title indicates this file defines the top-level contents or structure of the documentation.\\n\\n- The \\\&quot;.. toctree::\\\&quot; directive generates a table of contents from the listed files. \\n\\n- \\\&quot;maxdepth: 2\\\&quot; limits the nesting depth of subsections that will appear in the auto-generated TOC.\\n\\n- The listed files \\\&quot;usage\\\&quot;, \\\&quot;api\\\&quot;, and \\\&quot;syntax\\\&quot; are other documentation files that will be included in the navigation/TOC for the docs.\\n\\nSo in summary, this file:\\n\\n- Defines the top-level contents and structure of the documentation \\n- Generates a table of contents from the listed files\\n- Allows easy navigation between the main documentation sections\\n\\nThe key function is to organize and define the top-level navigation for the Sphinx-generated documentation.\&quot;,\&quot;/table/tablerow.h\&quot;:\&quot;This file defines a TableRow struct that represents a row in a table.\\n\\nKey things:\\n\\n- It defines a TableRow struct that will represent a single row.\\n\\n- The TableRow contains an unordered_map called columns. This maps column names (strings) to DataType values. DataType is likely defined elsewhere but represents the possible types a column can have (int, string, etc).\\n\\n- This allows a TableRow to store a variable number of columns, with each column mapped by name to its value which can be of different data types.\\n\\n- There are no functions defined, just the struct. This is likely meant to be used elsewhere to represent rows in a table/database context.\\n\\n- Key \\\&quot;functions\\\&quot; would be things like adding/removing columns via the columns map, accessing a column by name, iterating over columns, etc. But those functions are not defined here, just the data structure.\\n\\nSo in summary, it defines a struct that can represent a single row of data in a table, with columns mapped by name to different data types. No functions defined, just the data structure that will likely be used elsewhere.\&quot;,\&quot;/cmake-build-debug/.cmake/api/v1/reply/index-2024-01-17T14-57-04-0865.json\&quot;:\&quot;This file is a JSON response from CMake to a client (likely CLion) requesting build system information.\\n\\nKey things it provides:\\n\\n- Information about the CMake installation:\\n  - Generator name (MinGW Makefiles)\\n  - Version\\n  - Paths to cmake, cpack, ctest binaries\\n\\n- Metadata about JSON files containing build system data:\\n  - Kind of data (codemodel, cache, cmake files, toolchains)\\n  - Version \\n\\n- The actual requested data objects:\\n  - codemodel - Code model representing the C/C++ code\\n  - cache - CMake cache values\\n  - cmakeFiles - List of CMake files/scripts used\\n  - toolchains - Supported toolchain configurations\\n\\nSo in summary, its key functions are:\\n\\n1. Provide client with metadata about the CMake installation\\n2. List available build system data objects \\n3. Return the actual requested data objects (codemodel, cache, etc) in JSON format\\n\\nThis allows a client like CLion to retrieve critical build system information from CMake to enable features like code completion, code navigation, build execution, etc in the IDE.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/support/rtd/conf.py\&quot;:\&quot;This file is a Sphinx configuration file for Read the Docs (RTD), which is a service for hosting and building documentation.\\n\\nSome key things it does:\\n\\n- Sets the master_doc to \\u0027index\\u0027 - This tells Sphinx which document is the \\\&quot;main\\\&quot; or top-level document for the documentation build.\\n\\n- Sets the html_theme to \\u0027theme\\u0027 - This specifies which theme to use for building the HTML output. In this case it is using a custom theme located in the current directory (\\\&quot;.\\\&quot;).\\n\\n- Sets html_theme_path to [\\\&quot;.\\\&quot;] - This tells Sphinx where to find the custom HTML theme files. The \\\&quot;.\\\&quot; means look in the current directory. \\n\\nSo in summary, this file:\\n\\n- Configures Sphinx for building the documentation on RTD\\n- Sets the top-level/main document \\n- Specifies a custom HTML theme located in the current directory\\n- Tells Sphinx where to find the theme files\\n\\nThis allows the documentation to be built and styled properly when hosted on RTD using a custom theme defined locally.\&quot;,\&quot;/main.cpp\&quot;:\&quot;This file implements a basic database application with the following key functions:\\n\\n- It includes header files for table row, table, and database classes to define the data structures and functionality.\\n\\n- The main() function acts as the main loop that takes user commands and dispatches them.\\n\\n- It initializes a Database object db that will manage the tables. \\n\\n- It uses a while loop to continuously take user input commands like \\\&quot;CREATE\\\&quot;, \\\&quot;SAVE\\\&quot;, \\\&quot;LOAD\\\&quot;, etc. and branches the logic based on the main command.\\n\\n- The commands are not fully implemented yet, they just print messages or do nothing currently.\\n\\n- After the main loop, it demonstrates some database operations:\\n\\n  - db.loadTable() loads a table from a data file\\n\\n  - db.getTable() gets a table object from the database\\n\\n  - The table\\u0027s display() method prints out the table contents\\n\\n  - The table\\u0027s update() method updates a row based on a filter and new value\\n\\nSo in summary, it sets up the basic database classes and framework to take user commands to create, modify and query database tables stored on disk. The key classes are Database, Table and TableRow.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/support/docopt.py\&quot;:\&quot;This file implements a command line argument parser called docopt.\\n\\nKey things it does:\\n\\n- Parses a usage string and documentation to generate a pattern for matching arguments\\n- Tokenizes command line arguments \\n- Matches the tokens against the generated pattern\\n- Returns a dictionary of argument names and values\\n\\nKey functions:\\n\\n- parse_pattern - Parses the usage string and documentation into a pattern \\n- Tokens - Class for tokenizing command line arguments\\n- parse_argv - Parses command line tokens against the options pattern\\n- Pattern - Base class for nodes in the pattern tree\\n- LeafPattern/BranchPattern - Node classes for leaves/branches in pattern tree\\n- Required, Optional, etc - Pattern classes like required, optional, etc\\n- docopt - Main function that parses arguments and returns result dict\\n\\nSo in summary, it takes a usage string and documentation, generates a pattern from it, matches the command line tokens against that pattern, and returns a parsed result dictionary. The core is using a pattern tree to represent the possible argument structures.\&quot;,\&quot;/cmake-build-debug/.cmake/api/v1/reply/codemodel-v2-4e2f59f593edfc3db4a5.json\&quot;:\&quot;This file contains the CMake code model for a C++ project build configuration.\\n\\nSome key things it does:\\n\\n- Defines the \\\&quot;Debug\\\&quot; build configuration \\n- Lists the directories involved in the build, including source and build locations\\n- Defines the projects (the main project and any subprojects like FMT)\\n- Lists the targets, which correspond to executable/library build outputs\\n- References JSON files that contain more detailed information about each directory, project and target\\n\\nKey functions:\\n\\n- Describes the overall build configuration (name, directories, projects, targets)\\n- Provides unique IDs and filenames for each target \\n- Links directories, projects and targets together in a hierarchical structure\\n- Allows tools like IDEs to load and understand the full CMake-defined build system\\n- Acts as the entry point for querying detailed information about each component via the referenced JSON files\\n\\nSo in summary, it provides a high-level overview of the CMake-defined build that tools can use to understand and interact with the project build outputs and dependencies.\&quot;,\&quot;/utils/parser.cpp\&quot;:\&quot;This file contains a Parser class that is used to parse SQL statements.\\n\\nKey things:\\n\\n- The file is including the parser.h header file, which likely declares the Parser class.\\n\\n- There is a Parser::parseCreateTable() method. This suggests the Parser class has a method to parse a CREATE TABLE SQL statement. \\n\\n- parseCreateTable() is currently empty and just returns an empty string. This is likely a placeholder or work in progress implementation.\\n\\n- There are no other methods defined in this file. Other parsing methods like parseSelect(), parseInsert(), etc would likely be defined either here or in the parser.h header.\\n\\nSo in summary:\\n\\n- Contains a Parser class definition \\n- Parser has a method to parse CREATE TABLE statements\\n- Likely parses other SQL statements as well which are not yet implemented\\n- Acts as an interface to parse SQL and extract information from statements\\n\\nThe key function listed in this file is Parser::parseCreateTable() which is intended to parse a CREATE TABLE SQL statement. Other parsing functionality is suggested but not yet implemented in this file.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/doc/usage.rst\&quot;:\&quot;This file documents how to use the fmt formatting library. Some key points:\\n\\n- It describes how to build the library from source using CMake. This allows integrating fmt as a subproject or finding an installed version.\\n\\n- It provides instructions for various build systems like Meson, build2, etc to integrate fmt. \\n\\n- It explains how to install the pre-built library on various platforms using package managers like Conda, vcpkg, Homebrew etc.\\n\\n- It documents how to build the documentation using Doxygen and Less. \\n\\n- It contains an overview of the main usage patterns like including headers, linking to targets, header-only usage etc.\\n\\nSo in summary, this file:\\n\\n- Documents building and installing fmt \\n- Provides integration instructions for various build systems\\n- Explains documentation building\\n- Overviews basic usage patterns\\n\\nThe key functions are to educate users on how to obtain and utilize the fmt library within their own projects and codebases across different platforms and build environments.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/doc/api.rst\&quot;:\&quot;This file contains API documentation for the fmt formatting library.\\n\\nKey things it does:\\n\\n- Documents the main headers and what they provide (format.h, core.h, ranges.h, chrono.h, etc.)\\n\\n- Describes the core formatting functions like format(), print(), vformat()\\n\\n- Explains how to make user-defined types formattable via format_as() or formatter specializations \\n\\n- Documents utilities like format_args, format_context, format strings\\n\\n- Covers support for standard library types, ranges/tuples, dates/times, ostream, printf formatting\\n\\n- Mentions compile-time format string checks and compilation\\n\\n- Documents terminal color/styling support\\n\\n- Lists system APIs and wchar_t support\\n\\nSome key functions it documents:\\n\\n- format(), print() - core formatting functions\\n- format_as() - make type formattable via another type\\n- formatter\\u003c\\u003e - customize formatting for a type \\n- format_args, format_context - argument handling\\n- localtime(), gmtime() - date/time formatting\\n- streamed() - format via ostream\\n- printf() - printf-style formatting\\n- fg(), bg() - terminal text colors\\n\\nSo in summary, it provides API documentation and explains how to use the main features of the fmt formatting library.\&quot;,\&quot;/database/database.cpp\&quot;:\&quot;This file defines a Database class that manages tables of data.\\n\\nThe key functions are:\\n\\n- getTable(name) - Returns a pointer to the Table object with the given name. Returns null if not found.\\n\\n- addTable(table) - Adds a new Table object to the database. \\n\\n- loadTable(filePath) - Loads data from a file at the given path into a new Table object and adds it to the database. \\n\\nThe file:\\n\\n- Defines a std::vector of Table objects to store the tables\\n- getTable searches the vector by name and returns a pointer \\n- addTable pushes a new Table to the vector\\n- loadTable opens the file, reads the table schema and data, creates a Table object, populates it, and adds it to the vector.\\n\\nSo in summary, it provides functions to retrieve tables by name, add new tables, and load table data from files into the in-memory database representation.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/test/util.h\&quot;:\&quot;This file contains test utilities for the formatting library (fmt).\\n\\nKey functions:\\n\\n- safe_sprintf - Safely formats a string into a buffer using snprintf. Handles platform differences.\\n\\n- open_buffered_file - Opens a file for reading and returns a buffered_file object.\\n\\n- safe_fopen - Safely opens a file for reading/writing, handling platform differences. \\n\\n- basic_test_string - Simple string class for tests that stores a string value.\\n\\n- operator\\u003c\\u003c - Output stream operator for basic_test_string.\\n\\n- date - Simple date class for tests storing year, month, day.\\n\\n- get_locale - Gets a locale by name, or the classic locale if not available.\\n\\nSo in summary, it provides various utility functions and classes to help write cross-platform tests for the formatting library, including safe string formatting, file handling, simple string/date classes for tests, and locale support.\&quot;,\&quot;/cmake-build-debug/.cmake/api/v1/reply/directory-_deps.fmt-build-Debug-dd7b34a7b07e46720069.json\&quot;:\&quot;This file contains information about the installers used when installing the fmt library as a dependency.\\n\\nKey things:\\n\\n- backtraceGraph: Contains information about the CMake files and lines that led to the install command being executed.\\n\\n- installers: The list of installers used:\\n\\n  - Target installer: Installs the fmt library file (libfmtd.a) to the lib directory\\n\\n  - File installer: Installs header files to the include/fmt directory\\n\\n  - File installer: Installs CMake config files to lib/cmake/fmt\\n\\n  - Export installer: Exports target information to a CMake file for downstream projects\\n\\n  - File installer: Installs pkg-config file to lib/pkgconfig\\n\\n- paths: Lists the build and source paths for fmt\\n\\nSo in summary, this file describes the installers (where files get copied to) that were used when installing the fmt dependency library as part of the CMake build process. It traces back to the CMake code that triggered the install and provides details on what got installed and where.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/doc/build.py\&quot;:\&quot;This file is used to build the documentation for the fmt library.\\n\\nKey functions:\\n\\n- create_build_env(): Creates a virtualenv and installs Sphinx, Breathe and other dependencies needed for building the docs.\\n\\n- build_docs():\\n  - Runs Doxygen to generate XML documentation from header files\\n  - Runs Sphinx to build HTML docs from the XML and reStructuredText sources\\n  - Compiles the Less stylesheet to CSS\\n\\n- Pip class: Used to install packages into the virtualenv\\n\\nSo in summary, it:\\n\\n1. Sets up a virtualenv \\n2. Runs Doxygen to extract docs from headers\\n3. Runs Sphinx to build HTML from Doxygen XML and RST files\\n4. Compiles the Less stylesheet\\n\\nThis allows building the documentation in a clean, isolated environment and automates the process of generating docs from code comments and external sources.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/doc/index.rst\&quot;:\&quot;This file is the index or overview page for the fmt formatting library documentation.\\n\\nSome key things it does:\\n\\n- Provides an overview and introduction to the fmt library.\\n\\n- Describes the format API and how to use fmt::format, fmt::print, positional/named arguments, etc. \\n\\n- Covers safety features like type safety, exception handling for errors, compile-time checks.\\n\\n- Discusses compact binary code generation, portability, and ease of use.\\n\\n- Links to other documentation pages for things like the format string syntax, API reference, contents page. \\n\\n- Includes code samples demonstrating common usage patterns.\\n\\n- Embeds things like user quotes, buttons to the GitHub repo, etc. to enhance the documentation.\\n\\nSo in summary, it serves as the landing page and top-level introduction to what the fmt library is and how to use its main formatting functions. It highlights key features and acts as a gateway to the rest of the documentation.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/support/bazel/README.md\&quot;:\&quot;This file provides documentation on how to set up Bazel support for the fmt (formatting) library.\\n\\nKey functions:\\n\\n- Explains how to copy Bazel-related files (BUILD.bazel, WORKSPACE.bazel, .bazelversion) from the fmt repo\\u0027s support/bazel folder to the root of the fmt repo, to \\\&quot;bazelize\\\&quot; it.\\n\\n- Shows an example Bazel WORKSPACE file that fetches the fmt repo from GitHub and applies patches to move the Bazel files to the root. This makes fmt usable as a dependency. \\n\\n- Shows an example BUILD file that defines a binary target with a dependency on the @fmt repository rule. \\n\\n- Explains how to build and run the example binary using Bazel.\\n\\n- Mentions that the Bazel Central Registry also provides a module for using fmt with Bazel via Bzlmod.\\n\\nSo in summary, it documents how to set up the necessary Bazel configuration to be able to import and use the fmt library from Bazel-built projects via the bazel build system.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/support/manage.py\&quot;:\&quot;This Python file is used to manage releases and the documentation site for the fmt formatting library.\\n\\nThe key things it does:\\n\\n- Handles updating the Git repositories for fmt and the documentation site\\n- Updates documentation for a given version of fmt by checking out the code, fixing issues, and building the docs\\n- Updates the changelog and version number in CMakeLists.txt for a release\\n- Commits the changes and pushes to GitHub\\n- Creates a draft release on GitHub and uploads the package\\n\\nKey functions:\\n\\n- release(args) - Handles the full release process\\n- update_site(env) - Updates the documentation site by building docs for each version  \\n- create_build_env() - Sets up the build environment \\n- Git class - Wraps Git commands\\n- clean_checkout() - Cleans and checks out a Git branch\\n- rewrite() - Context manager to rewrite files in-place\\n\\nSo in summary, it automates the tasks of preparing a release, updating documentation for multiple versions, and publishing the changes to GitHub and the documentation site.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/doc/_templates/layout.html\&quot;:\&quot;This file is a custom layout template for Sphinx documentation generated with the fmt formatting library.\\n\\nKey functions:\\n\\n- Extends the base Sphinx layout template \\n- Adds extra metadata like description, keywords, author\\n- Includes Google Analytics tracking script\\n- Defines a search form macro\\n- Defines the page header with navigation menu\\n- Conditionally displays download buttons on index page  \\n- Disables related links sidebar\\n- Defines page content container\\n- Includes Bootstrap JS at bottom for enhanced styling\\n\\nIn summary, it:\\n\\n- Customizes the overall page layout and design\\n- Adds analytics tracking\\n- Renders the navigation menu\\n- Handles downloads/versions on index\\n- Defines where content is displayed\\n- Includes necessary CSS/JS assets\\n\\nSo in one template it controls the global template structure and common elements across all documentation pages generated with Sphinx for the fmt library website.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/test/fuzzing/fuzzer-common.h\&quot;:\&quot;This file contains common definitions and utilities used for fuzz testing the fmt formatting library.\\n\\nKey things it does:\\n\\n- Defines macros to configure fuzz testing behavior, like whether to format to a string or buffer, and whether to use separate allocation.\\n\\n- Defines a fixed size (16 bytes) that data will be treated as to allow cross-pollination between different types when mutating data. \\n\\n- Provides type casting utilities like as_chars() and as_bytes() to cast data to character/byte pointers.\\n\\n- assign_from_buf() utility to copy bytes from data into a constructed object of a given type.\\n\\n- data_to_string struct that handles formatting data to a string or buffer based on configuration, and provides access to the result.\\n\\nKey functions:\\n\\n- as_chars()/as_bytes() - Type casting utilities\\n- assign_from_buf() - Construct object from byte data \\n- data_to_string - Handles formatting data to string/buffer and accessing result\\n\\nSo in summary, it provides common code and structures to handle fuzz testing of formatting different data types to strings/buffers using the fmt library.\&quot;,\&quot;/cmake-build-debug/CMakeFiles/CMakeConfigureLog.yaml\&quot;:\&quot;This file is a CMake configure log file that records the output and results of running CMake on a project.\\n\\nSome key things it does:\\n\\n- Records system information like OS, architecture etc when CMake runs.\\n\\n- Records results of detecting the C and C++ compilers - it compiles and runs simple programs to get compiler IDs, versions etc. \\n\\n- Records parsing of compiler include paths and libraries from the compiler output.\\n\\n- Records results of \\\&quot;try compile\\\&quot; tests run by CMake modules to detect compiler properties like ABI. These compile and link small test programs.\\n\\n- Ignores/filters out large amounts of compiler output like compiler specs, headers searched etc to keep the log concise. \\n\\nKey functions:\\n\\n- message - Records status/informational messages from CMake scripts\\n- try_compile - Runs a compile+link test and records result \\n- Parses compiler output for things like include paths, libraries used in linking\\n- collapse/simplify include paths to canonical forms\\n- ignore/filter out lines from compiler output\\n- Implicitly records results of various CMake tests run during configuration\\n\\nSo in summary, it logs the process and results of CMake detecting the build environment like compilers, properties during the initial configuration phase.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-src/support/printable.py\&quot;:\&quot;This file is used to generate code for determining if a Unicode codepoint is printable in Rust.\\n\\nKey things it does:\\n\\n- Parses the UnicodeData.txt file to get codepoint classifications\\n- Groups codepoints into ranges of printable/non-printable codepoints \\n- Compresses the data into more efficient representations for single codepoints and ranges\\n- Prints out Rust code defining arrays and functions for efficiently checking if a codepoint is printable\\n\\nKey functions:\\n\\n- get_codepoints - Parses the Unicode data file\\n- to_ranges - Groups codepoints into contiguous ranges  \\n- compress_singletons/compress_normal - Compresses the data \\n- print_singletons/print_normal - Prints out Rust code defining the compressed data arrays\\n- main - Orchestrates the overall process\\n\\nSo in summary, it analyzes Unicode data, compresses it, and generates optimized Rust code for checking Unicode printability based on the compressed representation. This allows printability checks to be done very efficiently at runtime in Rust programs.\&quot;,\&quot;/cmake-build-debug/_deps/fmt-subbuild/CMakeFiles/CMakeConfigureLog.yaml\&quot;:\&quot;This file is the CMake configure log for the fmt subproject of the overall CMake project.\\n\\nSome key things about this file:\\n\\n- It logs messages and events from the CMake configuration process.\\n\\n- The main event logged here is a \\\&quot;message\\\&quot; event, indicating a message was printed during configuration. \\n\\n- The message shows that CMake determined the system is Windows 10 AMD64.\\n\\n- The backtrace shows where this message originated from - the CMakeDetermineSystem.cmake module and the top-level CMakeLists.txt file.\\n\\n- Logging configuration events allows retracing steps if configuration fails or has issues.\\n\\n- Key functions of this file:\\n\\n  - Log configuration messages and events\\n\\n  - Provide backtraces to trace messages to their origin\\n\\n  - Allow debugging configuration problems by examining the log\\n\\n  - Record details of the system CMake is being run on\\n\\nSo in summary, this file logs the output and process of configuring the fmt subproject with CMake, to help debug issues and understand what system/platform is being built for.\&quot;}&quot;}" />
  </component>
</project>